树状数组即二叉索引树，是使用数组模拟树形结构的一种数据结构，可用于计算**前缀和**和**区间和**(元素全为 1 时可用来**计数**)。采用数组而不是直接建树来解决问题是由于某些特定问题比如区间求和完全可以不建树就能解决，这样实现简单，复杂度低。这点上和 Trie 树有异曲同工之妙。

树状数组可以解决区间上的求和以及更新问题，应用广泛。

凡是树状数组能解决的问题，用**线段树**也能够解决，但树状数组的系数要少很多，因此实现比较简单。当然一些复杂区间问题还是得用线段树，树状数组功能有限。

时间复杂度上，修改和查询都是 O(logn)，比传统数组在求和时要快很多，而且容易实现。

## 树状数组(二叉索引树)

二叉树的结构可以使用下图来表示，相较于传统的树型图，这里为了说明做了对齐。

![[Pasted image 20230312175247.png]]

假设叶子结点全部来自一个数组，如果在所有父亲结点存储其直接后代节点的和，那么所有的父亲结点都存储了数组某个区间和，根节点储存了整个数组的和。

理论上如上所述。实际实现时，为了能用数组存储并且实现额外的功能，采用如下的形式来存储：

![[Pasted image 20230312175308.png]]

即多叉树，一部分节点存数组的一个元素值，另一部分数组存区间和。

叶子节点(黑色)代表原始数组 A，非叶节点(红色)代表树状数组 B，那么 B 可以由 A 的值按如下方式进行构造。

```
B[1] = A[1]
B[2] = A[1] + A[2]
B[3] = A[3]
B[4] = A[1] + A[2] + A[3] + A[4]
B[5] = A[5]
B[6] = A[5] + A[6]
B[7] = A[7]
B[8] = A[1] + A[2] + A[3] + A[4] + A[5] + A[6] + A[7] + A[8]
```

- 如果索引从 1 开始，那么奇数位置存数组原值，偶数位置存区间和。
- 如果索引从 0 开始，那么偶数位置存数组原值，奇数位置存区间和。

实际实现都是从 1 开始，舍弃掉 0 的空间，我觉得可能是为了和树的概念对齐，因为树的根节点为 1 号节点。这篇博文默认索引从 1 开始。

可以归纳出如下规律：
$$B[i] = A [i − 2^k + 1] + A [i − 2^k + 2] + ... + A [i]$$
编程可用循环实现。

其中 k 表示从 i 的二进制表示下最低位到最高位连续 0 的长度(或者说 1 左移 k 位等于 i)，如果 i 为奇数(即最低位直接就是 1 了)，则为 0，此时$B[i]=A[i]$。

区间求和如何实现：
$$SUM_i = B[i] + B[i-2^{k_1}]+B[(i-2^{k_1})-2^{k_2}]+...$$
编程可以使用循环实现。

循环一个必要步骤是计算$2^k$，不难得到$2^k=i\&(i \oplus (i-1))$，i 异或 i-1 从得到低位开始的第一个 1 之间全为 0 的 mask，与运算直接得到了 2 右移 k 位的结果。

而$i \oplus (i-1) = -i$，因为负数采用补码存储，等价于原码取反后加 1，等价于 i 和 i-1 异或。

那么$2^k=i\&(-i)$，这个运算有专门的称呼 lowbit。

## C++代码

```c++
int n;
int b[1005];

int lowbit(int x) {
    return x&(-x);
}

void update(int i, int k) {
    while(i < n) {
        b[i] += k;
        i += lowbit(i);
    }
}

int getSum(int i) {
    int res = 0;
    while(i > 0) {
        res += b[i];
        i -= lowbit(i);
    }
    return res
}
```

## 树状数组的几种变式(区间更新，区间查询)

上面介绍的是最普通的单点更新，区间查询，但如果有些时候是区间更新，单点求和怎么半，又或是区间更新，区间求和怎么办。这里将介绍各种情况该怎么写。

如果上面的单点更新，区间查询还没看懂，建议再思考再往下看。

### 1.单点更新、单点查询

传统数组可做

### 2.单点更新、区间查询

已讲解，详细看上面

### 3.区间更新、单点查询

这就是第一个问题，如果题目是让你把 x-y 区间内的所有值全部加上 k 或者减去 k，然后查询操作是问某个点的值，这种时候该怎么做呢。如果是像上面的树状数组来说，就必须把 x-y 区间内每个值都更新，这样的复杂度肯定是不行的，这个时候，就不能再用数据的值建树了，这里我们引入差分，利用差分建树。

假设我们规定$A[0] = 0$;

则有  $$A[i] = Σij = 1D[j];(D[j] = A[j] - A[j-1])$$，即前面 i 项的差值和，这个有什么用呢？例如对于下面这个数组

- A[] = 1 2 3 5 6 9
- D[] = 1 1 1 2 1 3

如果我们把`[2,5]`区间内值加上 2，则变成了

- A[] = 1 4 5 7 8 9
- D[] = 1 3 1 2 1 1

发现了没有，当某个区间`[x,y]`值改变了，区间内的差值是不变的，只有`D[x]`和`D[y+1]`的值发生改变，至于为什么我想我就不用解释了吧。

所以我们就可以利用这个性质对 D[]数组建立树状数组，代码为：

```c
1 int n,m;
 2 int a[50005] = {0},c[50005]; //对应原数组和树状数组
 3
 4 int lowbit(int x){
 5     return x&(-x);
 6 }
 7
 8 void updata(int i,int k){    //在i位置加上k
 9     while(i <= n){
10         c[i] += k;
11         i += lowbit(i);
12     }
13 }
14
15 int getsum(int i){        //求D[1 - i]的和，即A[i]值
16     int res = 0;
17     while(i > 0){
18         res += c[i];
19         i -= lowbit(i);
20     }
21     return res;
22 }
23
24 int main(){
25     cin>>n;27     for(int i = 1; i <= n; i++){
28         cin>>a[i];
29         updata(i,a[i] - a[i-1]);   //输入初值的时候，也相当于更新了值
31     }
32
33     //[x,y]区间内加上k
34     updata(x,k);    //A[x] - A[x-1]增加k
35     updata(y+1,-k);        //A[y+1] - A[y]减少k
36
37     //查询i位置的值
38     int sum = getsum(i);
39
40     return 0;
41 }
```

这样就把，原来要更新一个区间的值变成了只需要更新两个点。也很容易理解吧。

### 4.区间更新、区间查询

上面我们说的差值建树状数组，得到的是某个点的值，那如果我既要区间更新，又要区间查询怎么办。这里我们还是利用差分，由上面可知

$$∑^n_{i = 1}A[i] = ∑^n_{i = 1} ∑^i_{j = 1}D[j]$$

则
$A[1]+A[2]+...+A[n]$
$= (D[1]) + (D[1]+D[2]) + ... + (D[1]+D[2]+...+D[n])$
$= n*D[1] + (n-1)*D[2] +... +D[n]$
$= n * (D[1]+D[2]+...+D[n]) - (0*D[1]+1*D[2]+...+(n-1)*D[n])$

所以上式可以变为
$$∑^n_{i = 1}A[i] = n*∑^n_{i = 1}D[i] -  ∑^n_{i = 1}( D[i]*(i-1) )$$

如果你理解前面的都比较轻松的话，这里也就知道要干嘛了，维护两个数状数组，$sum1[i] = D[i]，sum2[i] = D[i]*(i-1)$;

```c
int n,m;
int a[50005] = {0};
int sum1[50005];    //(D[1] + D[2] + ... + D[n])
int sum2[50005];    //(1*D[1] + 2*D[2] + ... + n*D[n])

int lowbit(int x){
    return x&(-x);
}

void updata(int i,int k){
    int x = i;    //因为x不变，所以得先保存i值
    while(i <= n){
        sum1[i] += k;
        sum2[i] += k * (x-1);
        i += lowbit(i);
    }
}

int getsum(int i){        //求前缀和
    int res = 0, x = i;
    while(i > 0){
        res += x * sum1[i] - sum2[i];
        i -= lowbit(i);
    }
    return res;
}

int main(){
    cin>>n;
    for(int i = 1; i <= n; i++){
        cin>>a[i];
        updata(i,a[i] - a[i-1]);   //输入初值的时候，也相当于更新了值
    }

    //[x,y]区间内加上k
    updata(x,k);    //A[x] - A[x-1]增加k
    updata(y+1,-k);        //A[y+1] - A[y]减少k

    //求[x,y]区间和
    int sum = getsum(y) - getsum(x-1);

    return 0;
}
```
