## 什么是 RST

我们都知道 TCP 正常情况下断开连接是用四次挥手，那是正常时候的优雅做法。

但异常情况下，收发双方都不一定正常，连挥手这件事本身都可能做不到，所以就需要一个机制去强行关闭连接。

RST 就是用于这种情况，一般用来异常地关闭一个连接。它是一个 TCP 包头中的标志位。

正常情况下，不管是发出，还是收到置了这个标志位的数据包，相应的内存、端口等连接资源都会被释放。从效果上来看就是 TCP 连接被关闭了。

而接收到 RST 的一方，一般会看到一个 connection reset 或 connection refused 的报错。
![[640.png]]

## 怎么知道收到 RST 了？

我们知道内核跟应用层是分开的两层，网络通信功能在内核，我们的客户端或服务端属于应用层。应用层只能通过 send/recv 与内核交互，才能感知到内核是不是收到了 RST。

当本端收到远端发来的 RST 后，内核已经认为此链接已经关闭。

此时如果本端应用层尝试去执行 读数据操作，比如 recv，应用层就会收到 Connection reset by peer 的报错，意思是远端已经关闭连接。
![[640.gif]]
如果本端应用层尝试去执行写数据操作，比如 send，那么应用层就会收到 Broken pipe 的报错，意思是发送通道已经坏了。
![[640 (1).gif]]

## 出现 RST 的场景有哪些

RST 一般出现于异常情况，归类为 对端的端口不可用 和 socket 提前关闭。

### 端口不可用

端口不可用分为两种情况。要么是这个端口从来就没有"可用"过，比如根本就没监听（listen）过；要么就是曾经"可用"，但现在"不可用"了，比如服务突然崩了。

#### 端口未监听

![[640 (1).png]]
服务端 listen 方法会创建一个 sock 放入到全局的哈希表中。

此时客户端发起一个 connect 请求到服务端。服务端在收到数据包之后，第一时间会根据 IP 和端口从哈希表里去获取 sock。
![[640 (2).png]]
如果服务端执行过 listen，就能从全局哈希表里拿到 sock。

但如果服务端没有执行过 listen，那哈希表里也就不会有对应的 sock，结果当然是拿不到。此时，正常情况下服务端会发 RST 给客户端。

端口未监听就一定会发 RST 吗？
不一定。上面提到，发 RST 的前提是正常情况下，我们看下源码。

```c
// net/ipv4/tcp_ipv4.c
// 代码经过删减
int tcp_v4_rcv(struct sk_buff *skb)
{
    // 根据ip、端口等信息 获取sock。
    sk = __inet_lookup_skb(&tcp_hashinfo, skb, th->source, th->dest);
    if (!sk)
        goto no_tcp_socket;

no_tcp_socket:
    // 检查数据包有没有出错
    if (skb->len < (th->doff << 2) || tcp_checksum_complete(skb)) {
        // 错误记录
    } else {
        // 发送RST
        tcp_v4_send_reset(NULL, skb);
    }
}
```

内核在收到数据后会从物理层、数据链路层、网络层、传输层、应用层，一层一层往上传递。到传输层的时候，根据当前数据包的协议是 TCP 还是 UDP 走不一样的函数方法。可以简单认为，TCP 数据包都会走到 tcp_v4_rcv()。这个方法会从全局哈希表里获取 sock，如果此时服务端没有 listen()过 , 那肯定获取不了 sock，会跳转到 no_tcp_socket 的逻辑。

注意这里会先走一个 tcp_checksum_complete()，目的是看看数据包的校验和(Checksum)是否合法。

> 校验和可以验证数据从端到端的传输中是否出现异常。由发送端计算，然后由接收端验证。计算范围覆盖数据包里的 TCP 首部和 TCP 数据。

如果在发送端到接收端传输过程中，数据发生任何改动，比如被第三方篡改，那么接收方能检测到校验和有差错，此时 TCP 段会被直接丢弃。如果校验和没问题，那才会发 RST。

所以，只有在数据包没问题的情况下，比如校验和没问题，才会发 RST 包给对端。

为什么数据包异常的情况下，不发 RST？
一个数据包连校验都不能通过，那这个包，多半有问题。

有可能是在发送的过程中被篡改了，又或者，可能只是一个胡乱伪造的数据包。

五层网络，不管是哪一层，只要遇到了这种数据，推荐的做法都是默默扔掉，而不是去回复一个消息告诉对方数据有问题。

如果对方用的是 TCP，是可靠传输协议，发现很久没有 ACK 响应，自己就会重传。

如果对方用的是 UDP，说明发送端已经接受了“不可靠会丢包”的事实，那丢了就丢了。

因此，数据包异常的情况下，默默扔掉，不发 RST，非常合理。

#### 程序启动了但是崩了

端口不可用的场景里，除了端口未监听以外，还有可能是从前监听了，但服务端机器上做监听操作的应用程序突然崩了，此时客户端还像往常一样正常发送消息，服务器内核协议栈收到消息后，则会回一个 RST。在开发过程中，这种情况是最常见的。

比如你的服务端应用程序里，弄了个空指针，或者数组越界啥的，程序立马就崩了。
![[640 (3) 1.png]]
这种情况跟端口未监听本质上类似，在服务端的应用程序崩溃后，原来监听的端口资源就被释放了，从效果上来看，类似于处于 CLOSED 状态。

此时服务端又收到了客户端发来的消息，内核协议栈会根据 IP 端口，从全局哈希表里查找 sock，结果当然是拿不到对应的 sock 数据，于是走了跟上面"端口未监听"时一样的逻辑，回了个 RST。客户端在收到 RST 后也释放了 sock 资源，从效果上来看，就是连接断了。

#### RST 和 502 的关系

上面这张图，服务端程序崩溃后，如果客户端再有数据发送，会出现 RST。但如果在客户端和服务端中间再加一个 nginx，就像下图一样。
![[640 (4).png]]
nginx 会作为客户端和服务端之间的"中间人角色"，负责转发请求和响应结果。但当服务端程序崩溃，比如出现野指针或者 OOM 的问题，那转发到服务器的请求，必然得不到响应，后端服务端还会返回一个 RST 给 nginx。nginx 在收到这个 RST 后会断开与服务端的连接，同时返回客户端一个 502 错误码。

所以，出现 502 问题，一般情况下都是因为后端程序崩了，基于这一点假设，去看看监控是不是发生了 OOM 或者日志是否有空指针等报错信息。

### socket 提前关闭

这种情况分为本端提前关闭，和远端提前关闭。

#### 本端提前关闭

如果本端 socket 接收缓冲区还有数据未读，此时提前 close() socket。那么本端会先把接收缓冲区的数据清空，然后给远端发一个 RST。
![[640 (2).gif]]

#### 远端提前关闭

远端已经 close()了 socket，此时本端还尝试发数据给远端。那么远端就会回一个 RST。
![[640 (5).png]]
大家知道，TCP 是全双工通信，意思是发送数据的同时，还可以接收数据。

Close()的含义是，此时要同时关闭发送和接收消息的功能。

客户端执行 close()， 正常情况下，会发出第一次挥手 FIN，然后服务端回第二次挥手 ACK。如果在第二次和第三次挥手之间，如果服务方还尝试传数据给客户端，那么客户端不仅不收这个消息，还会发一个 RST 消息到服务端。直接结束掉这次连接。

## 对方没收到 RST，会怎么样？

我们知道 TCP 是可靠传输，意味着本端发一个数据，远端在收到这个数据后就会回一个 ACK，意思是"我收到这个包了"。

而 RST，不需要 ACK 确认包。

因为 RST 本来就是设计来处理异常情况的，既然都已经在异常情况下了，还指望对方能正常回你一个 ACK 吗？可以幻想，不要妄想。

但问题又来了，网络环境这么复杂，丢包也是分分钟的事情，既然 RST 包不需要 ACK 来确认，那万一对方就是没收到 RST，会怎么样？
![[640 (6).png]]
RST 丢了，问题不大。比方说上图服务端，发了 RST 之后，服务端就认为连接不可用了。

如果客户端之前发送了数据，一直没等到这个数据的确认 ACK，就会重发，重发的时候，自然就会触发一个新的 RST 包。

而如果客户端之前没有发数据，但服务端的 RST 丢了，TCP 有个 keepalive 机制，会定期发送探活包，这种数据包到了服务端，也会重新触发一个 RST。
![[640 (7).png]]

## 收到 RST 就一定会断开连接吗?

先说结论，不一定会断开。我们看下源码。

```c
// net/ipv4/tcp_input.c
static bool tcp_validate_incoming()
{
    // 获取sock
    struct tcp_sock *tp = tcp_sk(sk);

    // step 1：先判断seq是否合法（是否在合法接收窗口范围内）
    if (!tcp_sequence(tp, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq)) {
        goto discard;
    }

    // step 2：执行收到 RST 后该干的事情
    if (th->rst) {
        if (TCP_SKB_CB(skb)->seq == tp->rcv_nxt)
            tcp_reset(sk);
        else
            tcp_send_challenge_ack(sk);
        goto discard;
    }
}
```

收到 RST 包，第一步会通过 tcp_sequence 先看下这个 seq 是否合法，其实主要是看下这个 seq 是否在合法接收窗口范围内。如果不在范围内，这个 RST 包就会被丢弃。

至于接收窗口是个啥，我们先看下面这个图。
![[640 (8).png]]
这里黄色的部分，就是指接收窗口，只要 RST 包的 seq 不在这个窗口范围内，那就会被丢弃。

## 总结

- RST 其实是 TCP 包头里的一个标志位，目的是为了在异常情况下关闭连接。

- 内核收到 RST 后，应用层只能通过调用读/写操作来感知，此时会对应获得 Connection reset by peer 和 Broken pipe 报错。

- 发出 RST 后不需要得到对方的 ACK 确认包，因此 RST 丢失后对方不能立刻感知，但是通过下一次重传数据或 keepalive 心跳包可以导致 RST 重传。

- 收到 RST 包，不一定会断开连接，seq 不在合法窗口范围内的数据包会被默默丢弃。通过构造合法窗口范围内 seq，可以造成 RST 攻击
