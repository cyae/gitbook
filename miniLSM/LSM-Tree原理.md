索引基于B树的数据库可以快速地单点查询、范围查询, 但写操作的log在落盘时会产生随机IO, 这导致如innoDB等引擎的写操作变慢.

参考kafka的AOF思想, 变随机IO为顺序IO, 以此为出发点改造CRUD操作和存储模型.

尤其适用于**高频写**场景, 比如新片上映的流媒体播放平台, 需要定时记录每位用户的播放进度.

## 总体结构

`memtable`位于内存中, 仍然基于排序树(红黑树/AVL树/跳表)存储少量数据
![[Pasted image 20230204222728.png]]

当内存中的`memtable`达到指定大小, 启动落盘进程: 遍历排序树, 将结果存储为有序数组并清空`memtable`. 每次落盘形成1个`SSTable`
- 假如落盘过程宕机, 内存中的`memtable`会丢失. 可以单独在disk存储这些数据用于恢复, 比如每次写操作需要额外在disk中追加写.
![[Pasted image 20230204223139.png]]

按照优化写操作的思路:
- 读操作: 先查memtable, miss再对每一个SSTable进行二分搜索
- 写操作: 使用追加写覆盖旧值, 删除单独定义`tombstone`值
	- 对于写SSTable中途崩溃的问题, 参考TCP保证传输可靠性的方法, 如checksum机制等
- 这样优化的好处是: 只需要1个写线程在末尾执行写操作, 多个读线程可以并发读, 不存在并发控制问题

但是随着数据量增加:
- 追加写导致SSTable中存在大量无法删除的旧值
	- 在b树中也存在使用deleted标记被删除页, 导致的空洞问题. MySQL使用离线/在线重写技术使页结构紧凑化
- SSTable数量过多, 需要很多次二分查找
![[Pasted image 20230204223818.png]]

为了提高查找效率和存储利用率, 规定每当SSTable数目达到规定值, 开启bg线程触发合并操作(类似一次归并排序), 将若干SSTable合并/去除旧值
![[Pasted image 20230204224726.png]] 

## 基本改进

为了提升LSMTree的查询效率, 首先引入2种edge case改进策略

### 1. 水位指针

有些level的SSTable可能并不包含目标值, 但每次查询都需要二分所有层, 每层一次IO
![[Pasted image 20230204225743.png]]

**改进点**: 在内存中维护每一层的高低水位, 只有目标值位于水位区间才二分这一层
![[Pasted image 20230204225954.png]]

### 2. 布隆过滤器

二分查找前, 先使用布隆过滤器过滤一定不存在的值
![[Pasted image 20230204230231.png]]

### 3. 合并时机

合并的触发时机决定了最终的合并频率:
- 合并越频繁, SSTable尺寸越大, 适合读操作 => 分层合并 => RocksDB
- 合并越少次, SSTable尺寸越小, 适合写操作 => 分级合并 => Cassandra

#### 3.1 分级合并
先收集不合并, 只有当前SSTable中的数据装满才触发排序/合并
![[Pasted image 20230204230924.png]]

#### 3.2 分层合并
实时将上一层的SSTable排序/合并入本层
![[Pasted image 20230204231117.png]]