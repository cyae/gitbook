
## 事务简介

事务(Transaction)是操作数据库中某个数据项的一个程序执行单元(unit)。

事务应该具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性。

### 事务的四个特征

#### 1、Atomic 原子性

事务必须是一个原子的操作序列单元，事务中包含的各项操作在一次执行过程中，要么全部执行成功，要么全部不执行，任何一项失败，整个事务回滚，只有全部都执行成功，整个事务才算成功。

#### 2、Consistency 一致性

事务的执行不能破坏数据库数据的完整性和一致性，事务在执行之前和之后，数据库都必须处于一致性状态。

#### 3、Isolation 隔离性

在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰。

即不同的事务并发操纵相同的数据时，每个事务都有各自完整的数据空间，即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能相互干扰。

#### 4、Durability 持久性

持久性（durability）：持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久性的。

即使发生系统崩溃或机器宕机，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束时的状态。

> 比方说：一个人买东西的时候需要记录在账本上，即使老板忘记了那也有据可查。

### SQL 中的 4 个事务隔离级别

在数据库操作中，为了有效保证并发读取数据的正确性，提出的事务隔离级别。我们的数据库锁，也是为了构建这些隔离级别存在的。

### （1）读未提交

```css
如果一个事务正在处理某一数据，并对其进行了更新，
但同时尚未完成事务，或者说事务没有提交，
与此同时，允许另一个事务也能够访问该数据。
例如A将变量n从0累加到10才提交事务，此时B可能读到n变量从0到10之间的所有中间值。
```

**允许脏读。**在  **读未提交**  隔离级别下，允许  **脏读**  的情况发生。

脏读指的是读到了其他事务未提交的数据，

未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。

读到了并一定最终存在的数据，这就是脏读。

![img](https://pics7.baidu.com/feed/d01373f082025aaf5be5454896a1dd6d024f1a37.jpeg?token=15d738bce1e19daf55fa99c5fc036539)

脏读最大的问题就是可能会读到不存在的数据。

比如在上图中，事务 B 的更新数据被事务 A 读取，但是事务 B 回滚了，更新数据全部还原，也就是说事务 A 刚刚读到的数据并没有存在于数据库中。

### （2）读已提交

```css
只允许读到已经提交的数据。
即事务A在将n从0累加到10的过程中，B无法看到n的中间值，之中只能看到10。
```

在  **读已提交**  隔离级别下，**禁止了 脏读**，但是 允许**不可重复读**的情况发生

```css
事务A在将n从0累加到10的过程中，B无法看到n的中间值，之中只能看到10。
同时，
有事务C进行从10到20的累加，此时B在同一个事务内再次读时，读到的是20。
```

**不可重复读**指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据出现不一致的情况。

![img](https://pics1.baidu.com/feed/cf1b9d16fdfaaf51b5c3d1cbe318e2e7f01f7a73.jpeg?token=0a1d7df4e2f9fae479bc98bd763fd2ee)

**事务 A 多次读取同一数据，但事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果 不一致。**

不可重复读 一词，有点反人类，不好记忆。是从  **Nonrepeatable read**  翻译过来的，感觉英文的，好记忆一点。

### （3）可重复读

```undefined
保证在事务处理过程中，多次读取同一个数据时，其值都和事务开始时刻时是一致的。
```

在**可重复读**隔离级别下，禁止了：**脏读、不可重复读**。

但是，允许**幻读**。

在可重复读中，该 sql 第一次读取到数据后，就将这些数据加锁（悲观锁），其它事务无法修改这些数据，就可以实现可重复读了。

但这种方法却无法锁住 insert 的数据，所以当事务 A 先前读取了数据，或者修改了全部数据，事务 B 还是可以 insert 数据提交，

这时事务 A 就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。

### （4）串行化

```undefined
 最严格的事务，要求所有事务被串行执行，不能并发执行。
```

如果不对事务进行并发控制，我们看看数据库并发操作是会有那些异常情形

- （1）一类丢失更新：两个事物读同一数据，一个修改字段 1，一个修改字段 2，后提交的恢复了先提交修改的字段。
- （2）二类丢失更新：两个事物读同一数据，都修改同一字段，后提交的覆盖了先提交的修改。
- （3）脏读：读到了未提交的值，万一该事物回滚，则产生脏读。
- （4）不可重复读：两个查询之间，被另外一个事务修改（update）了数据的内容，产生内容的不一致。
- （5）幻读：两个查询之间，被另外一个事务插入或删除了（insert、delete）记录，产生结果集的不一致。

### 数据一致性和高性能，是天生的矛盾

无论是尼恩的 葵花宝典视频、还是 rocketmq 视频、还是推送中台实操视频，无一例外，都揭示了一个硬道理：**数据一致性和高性能，是天生的矛盾**

在事务领域，也是如此：

**场景一：性能最好的，一致性最差**

读未提交 的级别，它是性能最好，也可以说它是最野蛮的方式，因为它压根儿就不加锁，所以根本谈不上什么隔离效果，可以理解为没有隔离。

**场景二：一致性最好的，性能最差**

串行化就一致性性最强。 串行化相当于 处理一个人请求的时候，别的人都等着。

读的时候加共享锁，也就是其他事务可以并发读，但是不能写。写的时候加排它锁，其他事务不能并发写也不能并发读。

需要 Serializable 隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这都是非常悲观的 悲观锁策略， 这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。

**然后，就是 场景三： 在 高性能和数据一致性中间，寻找平衡。**

数据库的事务隔离越严格，并发副作用越小，但付出的代价越大；

**读提交和可重复读**, 都是在寻找平衡

这两种隔离级别是比较复杂的，既要允许一定的并发，又想要解决数据一致性问题。

oracle 默认事务隔离级别为读已提交(RC), 说明可以  **不可重复读**，（不可重复读 这个词用的反人类，）

MySQL 默认事务隔离级别为可重复读(RR),

ORACLE、MySQL、PostgreSQL 等成熟的数据库中的 读已提交、可重复读 隔离级别，并没有使用 Serializable 隔离级别中的悲观锁，都是使用了以乐观锁为理论基础的 MVCC（多版本并发控制）来实现。

### MySQL 的本地事务实现方案

大多数场景下，我们的应用都只需要操作单一的数据库，这种情况下的事务称之为本地事务(Local Transaction)。本地事务的 ACID 特性是数据库直接提供支持。

了解过 MySQL 事务的同学，就会知道，为了达成本地事务，MySQL 做了很多的工作，比如回滚日志，重做日志，MVCC，读写锁等。

**MySQL 数据库的事务实现原理**

以 MySQL 的 InnoDB （InnoDB 是 MySQL 的一个存储引擎）为例，介绍一下单一数据库的事务实现原理。

InnoDB 是通过 日志和锁 来保证的事务的 ACID 特性，具体如下：

（1）通过数据库锁的机制，保障事务的隔离性；

（2）通过 Redo Log（重做日志）来，保障事务的持久性；

（3）通过 Undo Log （撤销日志）来，保障事务的原子性；

（4）通过 Undo Log （撤销日志）来，保障事务的一致性；

**Undo Log 如何保障事务的原子性呢？**

具体的方式为：在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为 Undo Log），然后进行数据的修改。如果出现了错误或者用户执行了 Rollback 语句，系统可以利用 Undo Log 中的备份将数据恢复到事务开始之前的状态。

**Redo Log 如何保障事务的持久性呢？**

具体的方式为：Redo Log 记录的是新数据的备份（和 Undo Log 相反）。在事务提交前，只要将 Redo Log 持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是 Redo Log 已经持久化。系统可以根据 Redo Log 的内容，将所有数据恢复到崩溃之前的状态。

### 脏读、幻读、不可重复读

在多个事务并发操作时，数据库中会出现下面三种问题：**脏读，幻读，不可重复读**。

#### 脏读（Dirty Read)

事务 A 读到了事务 B 还未提交的数据：

事务 A 读取的数据，事务 B 对该数据进行修改还未提交数据之前，事务 A 再次读取数据会读到事务 B 已经修改后的数据，如果此时事务 B 进行回滚或再次修改该数据然后提交，事务 A 读到的数据就是脏数据，这个情况被称为脏读（Dirty Read）。

![img](https://img-blog.csdnimg.cn/20200811153200968.png)

#### 幻读（Phantom Read）

事务 A 进行范围查询时，事务 B 中新增了满足该范围条件的记录，当事务 A 再次按该条件进行范围查询，会查到在事务 B 中提交的新的满足条件的记录（**幻行** Phantom Row）。

![img](https://img-blog.csdnimg.cn/20200811155234313.png)

#### 不可重复读（Unrepeatable Read）

事务 A 在读取某些数据后，再次读取该数据，发现读出的该数据已经在事务 B 中发生了变更或删除。

![img](https://img-blog.csdnimg.cn/20200811155249156.png)

> **幻读和不可重复度的区别：**
>
> - **幻读**：在同一事务中，相同条件下，两次查询出来的  **记录数**  不一样；
> - **不可重复读**：在同一事务中，相同条件下，两次查询出来的  **数据**  不一样；

### 事务的隔离级别

为了解决数据库中事务并发所产生的问题，在标准 SQL 规范中，定义了四种事务隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。

> 低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。

**MySQL 事务隔离级别**：[https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html)

通过修改 MySQL 系统参数来控制事务的隔离级别，在 MySQL8 中该参数为  **transaction_isolation** ，在 MySQL5 中该参数为  **tx_isolation** :

```sql
MySQL8：
-- 查看系统隔离级别：
SELECT @@global.transaction_isolation;

-- 查看当前会话隔离级别
SELECT @@transaction_isolation;

-- 设置当前会话事务隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- 设置全局事务隔离级别
SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
```

**事务的四个隔离级别：**

- **未提交读（READ UNCOMMITTED）**：所有事务都可以看到其他事务未提交的修改。一般很少使用；
- **提交读（READ COMMITTED）**：Oracle 默认隔离级别，事务之间只能看到彼此已提交的变更修改；
- **可重复读（REPEATABLE READ）**：MySQL 默认隔离级别，同一事务中的多次查询会看到相同的数据行；可以解决不可重复读，但可能出现幻读；
- **可串行化（SERIALIZABLE）**：最高的隔离级别，事务串行的执行，前一个事务执行完，后面的事务会执行。读取每条数据都会加锁，会导致大量的超时和锁争用问题；

![img](https://img-blog.csdnimg.cn/20200811145639223.png)

> **问：如何保证 REPEATABLE READ 级别绝对不产生幻读？**
>
> **答**：在 SQL 中加入 for update (排他锁) 或 lock in share mode (共享锁)语句实现。就是锁住了可能造成幻读的数据，阻止数据的写入操作。
