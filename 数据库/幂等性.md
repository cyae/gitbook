---
date created: 2023-03-10 10:45
---

#数据存储

> 幂等性要求:记录无重复, 并且多次请求的返回状态值相同

## 出现场景

- 在 POST`form表单`时, 保存按钮不小心快速点了两次, 表中产生了两条重复的数据, 只是 id 不一样。
- 为了解决`接口超时`问题, 通常会引入了`超时重试`机制。第一次请求接口超时了, 请求方没能及时获取返回结果（此时有可能已经成功了）, 为了避免返回错误的结果（这种情况不能直接返回失败）, 于是会对该请求重试几次, 这样也会产生重复的数据。
- mq 消费者在读取消息时, 有时候会读取到`重复消息`, 如果处理不好, 也会产生重复的数据。
  - **生产者重复发送**
    - 生产者发送消息的时候, 必须等待 Broker 的响应。
    - 如果 Broker 的响应由于网络波动一时没有收到, 那么当超出等待时间之后, 通常生产者会因为没有收到响应而认为这条消息发送失败, 又会重复发送一次。
    - 最终导致两条消息都发送成功了, 消息队列有两条重复的消息, 这样就导致了消息的重复。
  - **消费者重复消费**
    - 消费者消费消息的时候, 如果业务逻辑已经走完了, 那么就需要提交 offset
    - 如果恰好此时消费者挂了, 那么被消费但是没有被提交的消息将被认为是消费失败
    - 此消息会被分发到其他消费者上, 导致一条消息被重复消费。

## 分类

- GET 请求不会改变记录状态, 因此天然是幂等的
- POST 请求可能产生重复记录
- PUT 请求
  - 如果只是对**不同**字段赋值**字面量**, 天然是幂等的, 如`UPDATE t_user SET age=18 WHERE id=1`
  - 否则, 可能产生非法结果, 如`UPDATE t_user SET age = age + 1 WHERE id=1`、`UPDATE t_user SET age=18 WHERE age=17`
- DELETE 请求
  - 对于服务端, 多次删除请求只会删除固定记录, 结果是幂等的
  - 对于客户端, 由于首次删除已经成功, 后续多次删除表中已无记录, 会返回内部错误

## 对策

### 悲观锁

- 首先加行级锁, 然后利用 GET 的幂等性进行判断, 如`SELECT * FROM t_user WHERE id=1 FOR UPDATE`
  - _**一定要注意, id 必须是主键或唯一索引, 否则行级锁会升级为表级锁, 数据量大, 非死即伤！！**_
- 如果不存在记录, 则 POST
- 否则, PUT
- 最后释放锁

### 乐观锁

- 利用**版本号机制**, 多次 PUT 请求只有一次能真正执行, 只需返回正常即可

```sql
update table_xxx set name=#name#,version=version+1 where version=#version#
```

- 针对具体业务场景，可以结合业务字段达到相同效果，比如减库存、扣钱等行为

```sql
update table_deposit set avai_amount=avai_amount-#subAmount# where avai_amount-#subAmount# >= 0
```

### Token 机制防止重复 request

- 原理同乐观锁，只是用**token 模拟版本号**，通过 session + token 来实现(也可以通过 redis 来实现)

1. 当客户端请求页面时，服务器会生成一个随机数 Token，并且将 Token 放置到 session 当中，然后将 Token 发给客户端（一般通过构造 hidden 表单）。
2. 下次客户端提交请求时，Token 会随着表单一起提交到服务器端。
3. 服务器端第一次验证相同过后，会将 session 中的**Token 值更新**，若用户重复提交，第二次的验证判断将失败，因为用户提交的表单中的 Token 没变，但服务器端 session 中 Token 已经改变了。

### 分布式锁

- **全局唯一索引**
  - 针对 POST 请求, 对某字段添加唯一索引, 之后如果有重复插入, 只需捕获`DuplicateKeyException`和`MySQLIntegrityConstraintViolationException(spring框架)`异常并 finally 返回正常即可
- **建全局防重表**
  - 针对 DELETE, 可以新建防重表, 每次 DELETE 都将记录的 id 插入防重表, 之后捕获异常并返回正常即可
- **基于 redis、zookeeper**

### 先查后改

- **并发不高**的后台系统，或者一些任务 JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了。
- 注意：核心高并发流程不要用这种方法；
- 可以用唯一索引、防重表等方法实现
- 唯一索引可以隐式地使用 request 特征字段构建，或者在 api 里要求用户附加

### 逻辑规避

- 将可能出现非幂等的操作换位幂等操作
- 如：当用户点击赞同时，将答案的赞同数量+1 => 当用户点击赞同时，确保答案赞同表中存在一条记录，用户、答案。赞同数量由答案赞同表统计出来
