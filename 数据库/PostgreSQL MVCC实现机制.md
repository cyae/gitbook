## MVCC
为了减少读写请求之间的相互影响，DB会保存逻辑记录的多个物理版本，以便于读老版本的同时，用户不会被写新版本的操作阻塞。
>比如，当开启事务时，当前版本被保存为快照，可供读请求读取历史记录，而不影响事务内对同一条记录的写操作。这称之为“快照读”

对于MVCC的设计，关键要考虑以下3点：
1. 如何**存储**历史版本？
2. 如何在历史版本中**找到**所需版本？
3. 如何**清理**过期版本？

*请注意，以上3点并非互相独立，它们很可能相互关联*

## PG的MVCC实现

### 版本存储 & 定位

PG采用类似LSM的方式，**每当**记录收到写请求，DB会在Before逻辑里先将当前记录**全量拷贝**到新表，然后对新记录执行update。

在新旧版本的记录之间，PG使用版本链（version chain）链接。版本链是单向链表，这是为了：
- 通过遍历版本链，找到所需版本
- 使用单向链表，可以减少空间overhead

在单向链表的指向设计上，存在2种设计：
|指向|特点|采用的DB|
|---|---|---|
|old2new|- 版本链头节点是初始版本，尾节点是最新版本；<br>- 需要完全遍历版本链以获取最新版本|PG|
|new2old|- 版本链尾节点是初始版本，头节点是最新版本；<br>- 只需访问头节点就能获取最新版本|Oracle、MySQL|
*注：PG为每条记录预设t_tcid字段作为指针指向新版本。B树叶子节点指向版本链的头节点。*

### 版本GC

过长的版本链意味着可能存在过期版本，这会导致：
1. 空间overhead
2. 版本链遍历时间加长
3. 影响优化器决策

PG采用类似JVM GC的策略，设计了过时版本回收器，当某版本的记录不被任何事务引用，便认为其过期，后续事务只能通过最新版本访问该记录。

PG的版本GC分定时触发和手动触发两种模式：
- 定时触发使用全局参数设置
- 手动触发使用 VACUUM 命令

### 设计缺陷

以上设计带来若干问题：
1. 每一次update都会触发拷贝操作，无论是改了记录的单个还是多个字段，即全量拷贝。
    - 这导致PG花费大量空间存储历史版本中的重复字段。
        - 对于写密集场景，一旦版本GC跟不上历史版本的累积速度，就会产生堰塞湖效应，若触发全表扫描，很容易导致慢SQL（有生产例子从30s暴涨到近1h）
    - 对比MySQL和Oracle存储的是新旧记录间的差异值
    - 有插件试图解决此问题（EnterpriseDB），但已不更新
2. 为了获取最新版本，需要遍历全部节点。为了弥补此缺陷，PG做了相关改动，包括：
    - 为了快速获取所需版本，将所有版本都加入索引B树。但也加剧了索引维护成本和query速度
    - HOT：将单条逻辑记录的所有版本存储在同一物理页上，减小IO和索引成本
3. PG对版本GC的实现也有差异
    - 默认的定时和手动触发都是类似JVM的标记-整理算法，只会将页上的过期版本清除，并聚集存活版本。这导致页面内空出大量碎片空间无法回收
    - 使用VACCUM FULL 或pg_repack插件，采用的是类似JVM的复制算法，会将不同页上的存活版本复制到