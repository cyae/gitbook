## MVCC
为了减少读写请求之间的相互影响，DB会保存逻辑记录的多个物理版本，以便于读老版本的同时，用户不会被写新版本的操作阻塞。
>比如，当开启事务时，当前版本被保存为快照，可供读请求读取历史记录，而不影响事务内对同一条记录的写操作。这称之为“快照读”

对于MVCC的设计，关键要考虑以下3点：
1. 如何存储历史版本？
2. 如何在历史版本中找到所需版本？
3. 如何清理过期版本？

*请注意，以上3点并非互相独立，它们很可能相互关联*

## PG的MVCC实现

### 历史版本存储

PG采用类似LSM的方式，**每当**记录收到写请求，DB会在Before逻辑里先将当前记录**完全拷贝**到新表，然后对新记录执行update。

在新旧版本的记录之间，PG使用版本链（version chain）链接。版本链是单向链表，这是为了：
- 通过遍历版本链，找到所需版本
- 使用单向链表，可以减少空间overhead

在单向链表的指向设计上，存在2种设计：
|指向|特点|采用的DB|
|---|---|---|
|old2new|- 版本链头节点是初始版本，尾节点是最新版本；<br>- 需要完全遍历版本链以获取最新版本|PG|
|new2old|- 版本链尾节点是初始版本，头节点是最新版本；<br>- 只需访问头节点就能获取最新版本|Oracle、MySQL|
*注：PG为每条记录预设t_tcid字段作为指针指向新版本*

### 设计缺陷

以上设计带来若干问题：
1. 每一次update都会触发拷贝操作
2. old2new的设计

