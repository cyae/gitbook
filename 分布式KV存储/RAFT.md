## 简介

如何多快好省地对大规模数据进行存储和计算？

- 更好的机器
- 更多的机器

如何让跨网络地机器之间协调一致地工作？

- 状态的强一致
- 状态的最终一致

如何应对网络的不可靠以及节点的失效？

- 可读写
- 可读
- 不可用

组织机器使其状态最终一致并允许局部失败的算法**为一致性算法**

Paxos 算法是目前**功能**和**性能**最完善的一致性算法，然而难以实现

raft 简化了 paxos，易于实现，功能性能接近

### 复制状态机

![[屏幕截图 2023-03-13 164349.png]]

一致性算法的目标是保证集群上所有节点的状态一致，节点要执行的指令可分为读和写。必须要保证写指令同步给所有节点。

理想状态下，我们期望任意节点发生的写命令都会立即反馈到其他节点的状态变更。但网络延迟导致了写指令不会同时执行，在其他节点上的写命令顺序会改变

一般使用日志维护写指令的顺序

### 问题定义

- 网络不确定性 分区、冗余、丢失、乱序
- 基本可用性 大部分节点能通信
- 不依赖时序 不依赖物理时钟或极端的消息延迟来保证一致性
- 快速响应 请求的响应不依赖于集群中最慢的节点

### 可行解

- 初始化状态有 1 个领导者节点，负责发送日志到跟随者，决定日志顺序
- 所有节点可处理读请求，领导者可处理写请求
- 领导者先写入自身日志，然后同步给半数以上跟随者，当反馈收到日志后，领导者提交日志
- 领导者崩溃后，跟随者通过心跳感知并选举新领导
- 有跟随者加入或退出时，要将元信息同步给所有节点

## 详细实现

### 状态机

![[屏幕截图 2023-03-13 165711.png]]

### 数据结构

![[屏幕截图 2023-03-13 165757.png]]
![[屏幕截图 2023-03-13 165809.png]]
![[屏幕截图 2023-03-13 165821.png]]

### 通用节点上的持久性状态

| 参数        | 解释                                                                                |
| ----------- | ----------------------------------------------------------------------------------- |
| currentTime | 服务器已知最新的任期（首次启动初始化为 0，单调递增）                                |
| votedFor    | 当前任期内收到选票的候选者 id，没有投票则为空                                       |
| log[]       | 日志条目，每个条目包含了状态机消耗的命令，以及领导者收到该条目时的任期（从 1 开始） |

### 通用节点上的易失性状态

| 参数        | 解释                                                 |
| ----------- | ---------------------------------------------------- |
| commitIndex | 已知已提交的最高日志条目的索引（初始为 0，单调递增） |
| lastApplied | 已知被消耗的最高日志条目的索引（初始为 0，单调递增） |

### 领导者节点上的易失性状态

| 参数         | 解释                                                                                       |
| ------------ | ------------------------------------------------------------------------------------------ |
| nextIndex[]  | 对于每一台服务器，发送到该服务器的下一个日志条目的索引（初始为领导者最后的日志条目索引+1） |
| matchIndex[] | 对于每一台服务器，已知的已经复制到该服务器的最高日志条目的索引（初始为 0，单调递增）       |

### RPC

- 候选人发起选举投票 RPC 到跟随者或候选人
- 领导者发起 RPC 到跟随者
  - 日志追加
  - 心跳

#### 请求投票时机

- 跟随者发现领导下线，变为候选人
- 选举超时

##### 请求投票参数

| 参数         | 解释                         |
| ------------ | ---------------------------- |
| term         | 候选人的任期号               |
| candidateId  | 候选人的 Id                  |
| lastLogIndex | 候选人的最后日志条目的索引   |
| lastLogTerm  | 候选人的最后日志条目的任期号 |

##### 返回值

| 参数        | 解释                                   |
| ----------- | -------------------------------------- |
| term        | 当前任期号，用于候选人更新自己的任期号 |
| voteGranted | 候选人赢得此选票则为真                 |

#### 追加日志 & 心跳 时机

- 客户端发起写请求
- 发送心跳
- 日志匹配失败

##### 请求参数

| 参数         | 解释                                                                                       |
| ------------ | ------------------------------------------------------------------------------------------ |
| term         | 领导者的任期                                                                               |
| leaderId     | 领导者 Id，因此跟随者可以对客户端进行重定向                                                |
| prevLogIndex | 紧邻新日志条目之前的那个日志条目的索引                                                     |
| prevLogTerm  | 紧邻新日志条目之前的那个日志条目的任期                                                     |
| entries[]    | 需要被保存的日志条目（被当作心跳使用时，则日志条目内容为空；为了提高效率可一次性发送多个） |
| leaderCommit | 领导者的已知已提交的最高日志条目的索引                                                     |

##### 返回值

| 参数    | 解释                                                      |
| ------- | --------------------------------------------------------- |
| term    | 当前任期号，对于领导者而言，他会更新自己的任期            |
| success | 跟随者所含有的条目的 prevLogIndex 和 prevLogTerm 匹配成功 |

## 算法原理与证明

### 5 条公理

| 特性             | 解释                                                                                                                   |
| ---------------- | ---------------------------------------------------------------------------------------------------------------------- |
| 选举安全特性     | 对于一个给定的任期号，最多只会有一个领导人被选举出来                                                                   |
| 领导人只附加原则 | 领导人绝对不会删除或者覆盖自己的日志，只会增加                                                                         |
| 日志匹配原则     | 如果两个日志在相同的索引位置的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间全部完全相同           |
| 领导人完全特性   | 如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中                               |
| 状态机安全特性   | 如果一个领导人已经将给定的索引值位置的日志条目应用到状态机中，那么其他任何的服务器在这个索引位置不会应用一个不同的日志 |

#### 选举安全特性

![[屏幕截图 2023-03-13 173219.png]]

> 在一个任期内半数以上的票数才能当选，保证每个任期要么 0 个领导要么 1 个领导。

#### 日志复制过程的完全匹配

1. 因为集群在任意时刻最多有一个 leader 存在,leader 在一个任期内只会在同一个索引处写入一次日志
2. 又因为领导者从来不会删除或者覆盖自己的日志,并且日志一旦写入就不允许修改
3. 所以只要任期和索引相同,那么在任何节点上的日志也都相同
4. 因为跟随者每次只会从与 leader 的 Prelog 匹配处追加日志，如果不匹配则 nextindex - 1 重试
5. 所以由递归的性质可知一旦踉随者和 leader 在 Prelog 处匹配，那么之前的所有日志就都是匹配的
6. 所以只要把 prelog 之后的日志全部按此次 Leader 同步 RPC 的日志顺序覆盖即可保证 二者的一致性

#### 安全性

每一任的领导者一定会有所有任期内领导者的全部已提交日志吗？

##### 选举限制

选民只会投票给任期比自己大，最后一条日志比自己新（任期大于或者等于时索引更大）的候选人。但这真的正确吗？

![[屏幕截图 2023-03-13 173246.png]]

1. 时刻 a, 51 是任期 2 的领导人并且向部分节点（51 和 S2）复制了 2 号位置的日志条目，然后岩机
2. 时刻 b, S5 获得了 S3、S4（ S5 的日志与 S3 和 S4 的一样新，最新的日志的任期号都是 1）和自己的 选票赢得了选举，成了 3 号任期的领导人，并且在 2 号位置上写入了一条任期号为 3 的日志条目。 在新日志条目复制到其他节点之前，S5 若机了、
3. 时刻 c, S1 重启，并且通过 S2、S3、S4 和自己的选票赢得了选举，成了 4 号任期的领导人，并且 继续向 S3 复制 2 号位置的日志。此时，任期 2 的日志条目已经在大多数节点上完成了复制
4. 时刻 d, S1 发生故障，S5 通过 S2、S3、”的选票再次成为领导人（因为 S5 最后一条日志条目的任 期号是 3,比 S2、S3、S4 中任意一个节点上的日志都更加新），任期号为 5。然后 S5 用自己的本 地日志夜写了其他节点上的日志
5. 上面这个例子生动地说明了，即使日志条目被半数以上的节点写盘（复制）了，也并不代表它已 经被提交（commited）到 Raft 集群了一因为一旦某条日志被提交，那么它将永远没法被删除或 修改。这个例子同时也说明了，领导人无法单纯地依靠之前任期的日志条目信息判断它的提交状 态
6. 因此，针对以上场景，Raft 算法对日志提交条件增加了一个额外的限制：要求 Leade「在当前任期 至少有一条日志被提交，即被超过半数的节点写盘
7. 正如上图中 e 描述的那样，S1 作为 Leader,在崩溃之前，将 3 号位置的日志（任期号为 4）在大多 数节点上复制了一条日志条目（指的是条目 3, term 4）,那么即使这时 51 若机了，S5 也不可能 赢得选举——因为 52 和 S3 最新日志条目的任期号为 4,比 S5 的 3 要大，S3 无法获得超过半数的选 票。”无法赢得选举，这就意味着 2 号位置的日志条目不会被覆写

所以新上任的领导者在接受客户端写入命令之前需要提交一个 no-op（空命令），携带自己任期号 的日志复制到大多数集群节点上才能真正的保证选举限制的成立。

##### 状态机安全性证明（三段论）

1. 定义 A 为上个任期最后一条已提交日志，B 为当前任期的 leader
2. 因为 A 必然同步到了集群中的半数以上节点
3. 又因为 B 只有获得集群中半数以上节点的选票后才能成为 leader
4. 所以 B 的选民中必然存在拥有 A 日志的节点
5. 又因为选举限制，B 成为 leader 的前提是比给它投票的所有选民都要新
6. 所以 B 的日志中必然要包含 A
7. 又因为日志完全匹配规则如果 A 被 B 包含，那么比 A 小的所有日志都被 B 包含
8. 因为 lastApplied <= commitIndex
9. 又因为「aft 保证弱交日志在所有集群节点上的顺序一致
10. 所以应用日志必然在在所有节点上顺序一致
11. 因为状态机只能按序执行应用日志部分
12. 得证状态机在整个集群所有节点上必然最终一致。

##### 状态机安全性证明（反证法）

1. 当日志条目 L 被同步给半数以上节点时,leaderA 会移动 8mmitIndex 指针提交日志，此时的日志被提 交
2. 当 leade「崩溃后，由一个新节点成为 leaderB,假设 leaderB 是第一个未包含 leaderA 最后已提交日 志的领导者
3. 选举过程中，只有获得半数以上节点认可才能成为 leader 因此至少有一个投票给当前 leaded 的节 点中含有已经提交的那条日志 L。
4. 那么根据选举限制，节点只会将选票投给至少与自己一样新的节点
   1. 节点 C 作为包含 leaderA 最后提交日志条目的投票者，如果 leade「B 与节点 C 的最后一条日志的任 期号一样大时，节点 C 的条目数一定大于 leaded,因为 leaded 是第一个未包含最后一条 LeaderA 日志的领导者。这与选举限制相矛盾，节点 C 不会投票给 leaderB、
   2. 如果 leaderB 最后一条日志的任期号大于节点 C 最后一条日志的任期号，那么 leaderB 的前任领 导中必然包含了 leaderA 已经提交的日志（leaderB 是第一个不包含 leaded 已提交日志的领导者中必然包含了 leaderA 已经提交的日志（leaderB 是第一个不包含 leade「A 已提交日志的领导者 这一假设）根据日志匹配特性 leaderB 也必须包含 leadecA 最后的已提交日志，这与假设矛盾。
5. 所以证明未来所有的领导者必然包含过去领导者已提交的日志，并且日志匹配原则，所有弱交日 志的顺序一定是一致的。
6. 又因为任意节点仅会将溺交日志按顺序应用于自身的状态机，更新 lastApplied 指针，因此所有节 点的状态机都会最终顺序一致。
7. 得证 raft 算法能够保证节点之间的协同工作。

## 工程优化

### 容错性

1. 领导者崩溃通过选举可以解决,但跟随者与候选人崩溃呢？

   > 基础的 raft 算法，通过无限次幕等的附加复制中 c 进行重试来解决。

2. 当平均故障时间大于信息交换时间，系统将没有一个稳定的领导者,集群无法工作

   > 广播时间<<心跳超时时间<<平均故障时间

3. 客户端如何连接 raft 的 server 节点？

   > 客户端随机选择一个节点去访问，如果是跟随者,跟随者会把自己知道的领导者告知客户端

4. 领导者提交后返回时崩溃,客户端重试不就导致相同的命令反复执行了吗？

   > 客户端为每次请求标记唯一序列号，服务端在状态中维护客户端最新的序列号标记进行幕等处理

5. 客户端给领导者 set a=3 并进行了提交，此时客户端如果从一个未被同步的节点读取 a 读不到写后的值

   > 每个客户端应该维持一个 latestldx 值，每个节点在接受读请求的时候与自己的 lastA 即仃 ed 值比较，如果 这个值大于自己的 lastApplied,则拒绝此次请求,客户端重定向到一个 lastApplied 大于等于自己 latestldx 的请求，并且每次读取请求都会返回这个节点的 lastA 即 lied 值，客户端将山 testldx 更新为此值， 保证读取的线性一致。

6. 如果 leader 被孤立，其他跟随者选举出 leader,但是当前 leader 还是向外提供脏数据怎么办？

   > 写入数据由于无法提交，因此会立即失败，但无法防止读到脏数据
   >
   > 解决办法是:心跳超过半数失败,leader 初到自己处于少数分区而被孤立进而拒绝提供读写服务

7. 当出现网络分区后，被孤立少数集合的节点无法选举，只会不断的增加自己的任期分区恢复后由 于失联的节点任期更大，会强行更新所有节点的任期，触发一次重新选举，而又因为其日志不够新， 被孤立的节点不可能成为新的 leader 所以，其状态机是安全的，只是触发了一次重新选举，使得集 群有一定时间的不可用。这是完全可以避免的

   > 在跟随者成为候选人时，先发送一轮 pre-vote rpc 来判断自己是否在大多数分区内(是否有半数节点

### 拓展性

- 集群的成员发生变化时,存在某一时刻新老配置共存，进而有选举出两个领导者的可能

![[屏幕截图 2023-03-13 173409.png]]

1. 新集群节点在配置变更期间必须获得老配置的多数派投票才靛成为 leader
2. 发送新配置 c-new 给集群的领导者
3. 领导者将自己的 c-old 配置与 c-new 合并为一个 c-old-new 配置
4. 然后下发给其他所有跟随者
   1. 当 c-old-new 被同步给半数以上节点后那么此配置已经提交遵循「aft 安全性机制
   2. 当 leade「在将 c-old-new 写入半数以上跟随者之前崩溃了，那么选举出来的新 lead 可会退回到 老的配置，此时重试更新配置即可
5. 当 c-old-new 被提交之后,leader 会真正的提交 c-new 配置
   1. 如果提交给了半数节点则 c-new 真正的被提交
   2. 如果未提交给半数节点时崩溃则新选举的 leader 必定包含已提交的 c-old-new 那么接着更新配置即可

集群变更过于复杂，因此可以简化这一过隹使用单节点变更机制，即每一次只添加或删除一个节点

![[屏幕截图 2023-03-13 173431.png]]

- 单节点变更时如果 leade「挂了造成一致性问题（丢失已提交日志）如何处理?

  - 新 leader 先发一条 no-op 日志再开始配置变更
  - [Raft 成员变更的工程实践](https://zhuanlan.zhihu.com/p/359206808)

- 单节点变更时偶数节点遇到网络分区，则没有办法选举 leader 了怎么办？

  - 重新定义偶数节点情况下的法定人数模型下的大多数情况（n/2 或者 n/2-l）
  - [TiDB 在 Raft 成员变更上踩的坑](https://blog.openacid.com/distributed/raft-bug/)
  - [后分布式时代: 多数派读写的’少数派’实现](https://blog.openacid.com/distributed/raft-bug/)

- 新的服务器没有存储任何日志，领导要复制很长一段时间此时不能参加选举否则会使得整体不可用

  - 新加入的节点设置一个保护期，在此保护期内不会参加选举与日志提交决策只用来同步日志

- 如果集群的领导不是新集群中的一员，该如何处理？

  - 在提交 c-new 时不将自己算作半雌交，并且在提交后要主动退位

- 被移除的节点如果不及时关闭，会导致选举超时后强行发起投票请求干扰在线集群
  - 每个节点如果未达到最小心跳超时时间，则不会进行投票。

### 性能

#### 生成快照

- 日志如果无限增长会将本地磁盘打满,这会造成可用性问题

![[屏幕截图 2023-03-13 173617.png]]

定时的将状态机中的状态生成快照，而将之前的日志全部删除，是一种常见的压缩方式

1. 将节点的状态保存为 LSM Tree,然后存储最后应用日志的索引与任期,以保证日志匹配特性
2. 为支持集群的配置更新,快照中也要将最后应用的集群配置也当做状态保存下来
3. 当跟随者需要的日志已经在领导者上面被删除时(nextindex-)，需要将快照通过 RPC 发送过
   _注意：由领导人调用以将快照的分块发送给跟随者。领导者总是按顺序发送分块。_

| 参数              | 解释                               |
| ----------------- | ---------------------------------- |
| term              | 领导人的任期号                     |
| leaderld          | 领导人的 Id,以便于跟随者重定向请求 |
| lastlncludedlndex | 快照中包含的最后日志条目的索引值   |
| lastlncludedTerm  | 快照中包含的最后日志条目的任期号   |
| offset            | 分块在快照中的字节偏移量           |
| data[]            | 从偏移量开始的快照分块的原始字节   |
| done              | 如果这是最后一个分块则为 true      |

| 结果 | 解程                                       |
| ---- | ------------------------------------------ |
| term | 当前任期号(currentTerm),便于领导人更新自己 |
