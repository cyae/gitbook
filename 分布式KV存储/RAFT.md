## 简介

如何多快好省地对大规模数据进行存储和计算？

- 更好的机器
- 更多的机器

如何让跨网络地机器之间协调一致地工作？

- 状态的强一致
- 状态的最终一致

如何应对网络的不可靠以及节点的失效？

- 可读写
- 可读
- 不可用

组织机器使其状态最终一致并允许局部失败的算法**为一致性算法**

Paxos算法是目前**功能**和**性能**最完善的一致性算法，然而难以实现

raft简化了paxos，易于实现，功能性能接近

### 复制状态机

![[屏幕截图 2023-03-13 164349.png]]

一致性算法的目标是保证集群上所有节点的状态一致，节点要执行的指令可分为读和写。必须要保证写指令同步给所有节点。

理想状态下，我们期望任意节点发生的写命令都会立即反馈到其他节点的状态变更。但网络延迟导致了写指令不会同时执行，在其他节点上的写命令顺序会改变

一般使用日志维护写指令的顺序

### 问题定义

- 网络不确定性 分区、冗余、丢失、乱序
- 基本可用性 大部分节点能通信
- 不依赖时序 不依赖物理时钟或极端的消息延迟来保证一致性
- 快速响应 请求的响应不依赖于集群中最慢的节点

### 可行解

- 初始化状态有1个领导者节点，负责发送日志到跟随者，决定日志顺序
- 所有节点可处理读请求，领导者可处理写请求
- 领导者先写入自身日志，然后同步给半数以上跟随者，当反馈收到日志后，领导者提交日志
- 领导者崩溃后，跟随者通过心跳感知并选举新领导
- 有跟随者加入或退出时，要将元信息同步给所有节点

## 详细实现

### 状态机

![[屏幕截图 2023-03-13 165711.png]]

### 数据结构

![[屏幕截图 2023-03-13 165757.png]]
![[屏幕截图 2023-03-13 165809.png]]
![[屏幕截图 2023-03-13 165821.png]]

### 通用节点上的持久性状态

参数|解释
---|---
currentTime|服务器已知最新的任期（首次启动初始化为0，单调递增）
votedFor|当前任期内收到选票的候选者id，没有投票则为空
log[]|日志条目，每个条目包含了状态机消耗的命令，以及领导者收到该条目时的任期（从1开始）

### 通用节点上的易失性状态

参数|解释
---|---
commitIndex|已知已提交的最高日志条目的索引（初始为0，单调递增）
lastApplied|已知被消耗的最高日志条目的索引（初始为0，单调递增）

### 领导者节点上的易失性状态

参数|解释
---|---
nextIndex[]|对于每一台服务器，发送到该服务器的下一个日志条目的索引（初始为领导者最后的日志条目索引+1）
matchIndex[]|对于每一台服务器，已知的已经复制到该服务器的最高日志条目的索引（初始为0，单调递增）

### RPC

- 候选人发起选举投票RPC到跟随者或候选人
- 领导者发起RPC到跟随者
  - 日志追加
  - 心跳

#### 请求投票时机

- 跟随者发现领导下线，变为候选人
- 选举超时

##### 请求投票参数

参数|解释
---|---
term|候选人的任期号
candidateId|候选人的Id
lastLogIndex|候选人的最后日志条目的索引
lastLogTerm|候选人的最后日志条目的任期号

##### 返回值

参数|解释
---|---
term|当前任期号，用于候选人更新自己的任期号
voteGranted|候选人赢得此选票则为真

#### 追加日志 & 心跳 时机

- 客户端发起写请求
- 发送心跳
- 日志匹配失败

##### 请求参数

参数|解释
---|---
term|领导者的任期
leaderId|领导者Id，因此跟随者可以对客户端进行重定向
prevLogIndex|紧邻新日志条目之前的那个日志条目的索引
prevLogTerm|紧邻新日志条目之前的那个日志条目的任期
entries[]|需要被保存的日志条目（被当作心跳使用时，则日志条目内容为空；为了提高效率可一次性发送多个）
leaderCommit|领导者的已知已提交的最高日志条目的索引

##### 返回值

参数|解释
---|---
term|当前任期号，对于领导者而言，他会更新自己的任期
success|跟随者所含有的条目的prevLogIndex和prevLogTerm匹配成功

## 算法原理与证明

### 5条公理

特性|解释
---|---
选举安全特性|对于一个给定的任期号，最多只会有一个领导人被选举出来
领导人只附加原则|领导人绝对不会删除或者覆盖自己的日志，只会增加
日志匹配原则|如果两个日志在相同的索引位置的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间全部完全相同
领导人完全特性|如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中
状态机安全特性|如果一个领导人已经将给定的索引值位置的日志条目应用到状态机中，那么其他任何的服务器在这个索引位置不会应用一个不同的日志

#### 选举安全特性

![[屏幕截图 2023-03-13 173219.png]]

>在一个任期内半数以上的票数才能当选，保证每个任期要么0个领导要么1个领导。

#### 日志复制过程的完全匹配

1. 因为集群在任意时刻最多有一个leader存在,leader在一个任期内只会在同一个索引处写入一次日志
2. 又因为领导者从来不会删除或者覆盖自己的日志,并且日志一旦写入就不允许修改
3. 所以只要任期和索引相同,那么在任何节点上的日志也都相同
4. 因为跟随者每次只会从与leader的 Prelog匹配处追加日志，如果不匹配则nextindex - 1 重试 
5. 所以由递归的性质可知一旦踉随者和leader 在 Prelog处匹配，那么之前的所有日志就都是匹配的 
6. 所以只要把prelog 之后的日志全部按此次Leader同步RPC的日志顺序覆盖即可保证 二者的一致性

#### 安全性

每一任的领导者一定会有所有任期内领导者的全部已提交日志吗？

##### 选举限制

选民只会投票给任期比自己大，最后一条日志比自己新（任期大于或者等于时索引更大）的候选人。但这真的正确吗？

![[屏幕截图 2023-03-13 173246.png]]

1. 时刻a, 51是任期2的领导人并且向部分节点（51和S2）复制了2号位置的日志条目，然后岩机
2. 时刻b, S5获得了S3、S4（ S5的日志与S3和S4的一样新，最新的日志的任期号都是1）和自己的 选票赢得了选举，成了3号任期的领导人，并且在2号位置上写入了一条任期号为3的日志条目。 在新日志条目复制到其他节点之前，S5若机了、
3. 时刻c, S1重启，并且通过S2、S3、S4和自己的选票赢得了选举，成了4号任期的领导人，并且 继续向S3复制2号位置的日志。此时，任期2的日志条目已经在大多数节点上完成了复制
4. 时刻d, S1发生故障，S5通过S2、S3、”的选票再次成为领导人（因为S5最后一条日志条目的任 期号是3,比S2、S3、S4中任意一个节点上的日志都更加新），任期号为5。然后S5用自己的本 地日志夜写了其他节点上的日志
5. 上面这个例子生动地说明了，即使日志条目被半数以上的节点写盘（复制）了，也并不代表它已 经被提交（commited）到Raft集群了一因为一旦某条日志被提交，那么它将永远没法被删除或 修改。这个例子同时也说明了，领导人无法单纯地依靠之前任期的日志条目信息判断它的提交状 态
6. 因此，针对以上场景，Raft算法对日志提交条件增加了一个额外的限制：要求Leade「在当前任期 至少有一条日志被提交，即被超过半数的节点写盘
7. 正如上图中e描述的那样，S1作为Leader,在崩溃之前，将3号位置的日志（任期号为4）在大多 数节点上复制了一条日志条目（指的是条目3, term 4）,那么即使这时51若机了，S5也不可能 赢得选举——因为52和S3最新日志条目的任期号为4,比S5的3要大，S3无法获得超过半数的选 票。”无法赢得选举，这就意味着2号位置的日志条目不会被覆写
  
所以新上任的领导者在接受客户端写入命令之前需要提交一个no-op（空命令），携带自己任期号 的日志复制到大多数集群节点上才能真正的保证选举限制的成立。

##### 状态机安全性证明（三段论）
1. 定义A为上个任期最后一条已提交日志，B为当前任期的leader
2. 因为A必然同步到了集群中的半数以上节点
3. 又因为B只有获得集群中半数以上节点的选票后才能成为leader
4. 所以B的选民中必然存在拥有A日志的节点
5. 又因为选举限制，B成为leade「的前提是比给它投票的所有选民都要新
6. 所以B的日志中必然要包含A

