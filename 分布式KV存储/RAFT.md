# RAFT 与 ETCD

## 简介

如何多快好省地对大规模数据进行存储和计算？

- 更好的机器
- 更多的机器

如何让跨网络地机器之间协调一致地工作？

- 状态的强一致
- 状态的最终一致

如何应对网络的不可靠以及节点的失效？

- 可读写
- 可读
- 不可用

组织机器使其状态最终一致并允许局部失败的算法**为一致性算法**

Paxos算法是目前**功能**和**性能**最完善的一致性算法，然而难以实现

raft简化了paxos，易于实现，功能性能接近

### 复制状态机

一致性算法的目标是保证集群上所有节点的状态一致，节点要执行的指令可分为读和写。必须要保证写指令同步给所有节点。

理想状态下，我们期望任意节点发生的写命令都会立即反馈到其他节点的状态变更。但网络延迟导致了写指令不会同时执行，在其他节点上的写命令顺序会改变

一般使用日志维护写指令的顺序

### 问题定义

- 网络不确定性 分区、冗余、丢失、乱序
- 基本可用性 大部分节点能通信
- 不依赖时序 不依赖物理时钟或极端的消息延迟来保证一致性
- 快速响应 请求的响应不依赖于集群中最慢的节点

### 可行解

- 初始化状态有1个领导者节点，负责发送日志到跟随者，决定日志顺序
- 所有节点可处理读请求，领导者可处理写请求
- 领导者先写入自身日志，然后同步给半数以上跟随者，当反馈收到日志后，领导者提交日志
- 领导者崩溃后，跟随者通过心跳感知并选举新领导
- 有跟随者加入或退出时，要将元信息同步给所有节点

## 详细实现

### 状态机

### 数据结构

### 通用节点上的持久性状态

参数|解释
---|---
currentTime|服务器已知最新的任期（首次启动初始化为0，单调递增）
votedFor|当前任期内收到选票的候选者id，没有投票则为空
log[]|日志条目，每个条目包含了状态机消耗的命令，以及领导者收到该条目时的任期（从1开始）

### 通用节点上的易失性状态

参数|解释
---|---
commitIndex|已知已提交的最高日志条目的索引（初始为0，单调递增）
lastApplied|已知被消耗的最高日志条目的索引（初始为0，单调递增）

### 领导者节点上的易失性状态

参数|解释
---|---
nextIndex[]|对于每一台服务器，发送到该服务器的下一个日志条目的索引（初始为领导者最后的日志条目索引+1）
matchIndex[]|对于每一台服务器，已知的已经复制到该服务器的最高日志条目的索引（初始为0，单调递增）

### RPC

- 候选人发起选举投票RPC到跟随者或候选人
- 领导者发起RPC到跟随者
  - 日志追加
  - 心跳

#### 请求投票时机

- 跟随者发现领导下线，变为候选人
- 选举超时

##### 请求投票参数

参数|解释
---|---
term|候选人的任期号
candidateId|候选人的Id
lastLogIndex|候选人的最后日志条目的索引
lastLogTerm|候选人的最后日志条目的任期号

##### 返回值

参数|解释
---|---
term|当前任期号，用于候选人更新自己的任期号
voteGranted|候选人赢得此选票则为真

#### 追加日志 & 心跳 时机

- 客户端发起写请求
- 发送心跳
- 日志匹配失败

##### 请求参数

参数|解释
---|---
term|领导者的任期
leaderId|领导者Id，因此跟随者可以对客户端进行重定向
prevLogIndex|紧邻新日志条目之前的那个日志条目的索引
prevLogTerm|紧邻新日志条目之前的那个日志条目的任期
entries[]|需要被保存的日志条目（被当作心跳使用时，则日志条目内容为空；为了提高效率可一次性发送多个）
leaderCommit|领导者的已知已提交的最高日志条目的索引

##### 返回值

参数|解释
---|---
term|当前任期号，对于领导者而言，他会更新自己的任期
success|跟随者所含有的条目的prevLogIndex和prevLogTerm匹配成功

## 算法原理与证明

### 公理


