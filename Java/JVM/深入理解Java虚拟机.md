## JVM 与 Java 体系结构

### 💡Java 虚拟机整体架构样图

![[Pasted image 20230313221618.png]]

### Java 代码执行过程详图

![[Pasted image 20230313221649.png]]

### 汇编语言、机器语言、高级语言关系

![[Pasted image 20230313221658.png]]

### JVM 的架构模型

- 基于栈式

  - 优点

    - 设计和实现简单，适用于资源受限的系统
    - 避开了寄存器的分配难题：使用零地址指令方式分配
    - 指令流中大部分都是零地址指令，执行过程依赖操作栈，指令集更小，编译器容易实现
      - 8 位字节码，所以说指令集更小，但是完成一项操作花费的指令相对多。
    - 不需要硬件支持，可移植性更好，更好实现跨平台

  - 缺点

    - 性能下降，实现同样的功能需要更多的指令，毕竟还要入栈出栈等操作

  - 指令
    - 地址、操作数
      - 零地址只有操作数
        - 基于栈式的，因为一定是操作栈顶的元素，所以不需要地址
      - 一地址有一个地址，一个操作数
      - 二地址有两个地址，一个操作数

- 基于寄存器式

  - 优点

    - 性能优秀，执行更高效
    - 花费更少的指令去完成一项操作

  - 缺点

    - 指令集架构完全依赖硬件，可移植性差

  - 典型应用是 X86 的二进制指令集，比如传统的 PC 以及安卓的 Davlik 虚拟机

    - 16 位字节码

  - 大部分情况下，指令集往往以一地址指令，二地址指令和三地址指令为主。

- javap 查看字节码
  - -v 输出附加信息
  - -l 输出行号和本地变量表
  - -p 显示所有类和成员
  - -c 对代码进行反汇编

### JVM 的生命周期

- 虚拟机的启动

  - 通过引导类加载器 bootstrap class loader 创建一个初始类来完成的，这个类是由虚拟机的具体实现指定的。

- 虚拟机的执行

  - 执行一个所谓的 Java 程序的时候，真正执行的是一个叫 Java 虚拟机的进程

- 虚拟机的退出
  - 程序正常执行结束
  - 执行过程遇到异常或错误而异常终止
  - 操作系统错误导致 Java 虚拟机进程终止
  - Runtime 类或 System 类的 exit 方法、runtime 类的 halt 方法，并且 Java 安全管理器允许这次 exit 或 halt 操作
    - halt 停止、停下、阻止
    - exit 方法源码：static native void halt0（int status）
  - JNI(Java Native Interface)规范描述了用 JNI Invocation API 来加载或卸载 Java 虚拟机时，Java 虚拟机退出的情况

### JVM 发展历程

- sun Classic VM

  - 世界第一款商用 Java 虚拟机
  - JDK1.4 时被淘汰
  - 只提供了解释器
  - 如果使用 JIT 编译器，就需要外挂，但是 JIT 和解释器不能配合工作

- Exact VM

  - 为了解决上一个虚拟机问题，JDK1.2 时，sun 提供了此虚拟机
  - Exact Memory Management：准确式内存管理

    - 虚拟机知道内存中某个位置的数据是什么类型

  - 具有现代高性能虚拟机的雏形

    - 热点探测
    - 编译器与解释器混合工作模式

  - 只在 Solaris 平台短暂使用，其他平台还是 Classic vm
    - 英雄气短，被 hotspot 虚拟机替换

- hotspot 虚拟机

  - 最初由 Longview Technologies 的小公司设计，1997 年被 sun 公司收购，2009 年 sun 公司被甲骨文收购
  - JDK1.3 时，HotSpot VM 成为默认虚拟机
  - 绝对市场地位，称霸武林

    - JDK6,8 等均默认

  - HotSpot 就是他的热点代码探测技术
    - 通过计数器找到最具编译价值代码，触发即时编译或栈上替换
    - 通过编译器与解释器协同工作，在优化响应时间和最佳执行性能中取得平衡

- JRockit

  - BEA 公司
  - 专注服务器端应用
    - 不太关注程序启动速度，引起 JRockit 内部不包括解析器实现，全部代码靠即时编译器编译后执行
  - 世界上最快的 JVM
  - 全面的 Java 运行时解决方案组合
    - JRockit Real Time 提供毫秒或微秒级的 JVM 响应时间，适合财务、军事指挥，电信网络的需要
    - MissionControl 服务套件，极低的开销，来监控、管理和分析生成环境中的应用程序的工具
  - 2008 年 BEA 被 oracle 收购
  - JDK8 中，在 HOTSPOT 的基础上，移植 JRockit 的优秀特性

- IBM J9

  - 全称：IBM Technology for java Virtual Machine 简称 IT4J，内部代号 J9
  - 市场定位与 HotSpot 接近，服务器端、桌面应用，嵌入式等多用途 VM
  - 广泛应用于 IBM 的各种 Java 产品
    - IBM 产品结合使用性能最好
  - 有影响力的三大商用虚拟机之一
  - 2017 开源，OPEN J9

- KVM 和 CDC/CLDC HotSpot

  - JavaME 产品线产品
    - 智能控制器、传感器、老人手机等

- Azul VM

  - 与特定硬件平台绑定、软硬件配合的专有虚拟机
  - 运行于 Azul Systems 公司的专有硬件 Vega 系统上的虚拟机
  - 每个实例可以管理至少数十个 CPU 和数百 GB 内存的硬件资源，并提供在巨大内存范围内实现可控的 GC 时间的垃圾收集器，专有硬件优化的线程调度等优秀特性
  - 2010 年，发布自己的 Zing JVM，可以在通用 X86 平台上提供接近于 vega 系统的特性

- Liquid VM

  - BEA 公司开发的，运行在自家 Hypervisor 系统上
  - 不需要操作系统支持，本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等
  - 随着 JRockit 虚拟机终止开发，Liquid VM 项目也停止了

- Apache Harmony

  - JDK1.5,1.6 兼容
  - IBM 和 Intel 联合开发的开源 JVM，2011 年退役
  - Java 类库代码吸纳进了 Android SDK

- Microsoft JVM

  - 只能在 Windows 平台运行，xp 系统中不用了。

- TaobaoJVM

  - 基于 OpenJDK 开发了自己的定制版本 AlibabaJDK
  - 深度定制且开源的高性能服务器版 JAVA 虚拟机
  - GCIH：GC invisible heap，将生命周期较长的 Java 对象从 heap 中已到 heap 之外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率
  - GCIH 中的对象还能够在多个 JAVA 虚拟机进程中实现共享
  - 使用 crc32 指令实现 JVM intrinsic 降低 JNI 的调用开销
  - 针对大数据场景的 ZenGC
  - 在阿里产品上性能高，硬件严重依赖 intel 的 CPU，损失了兼容性，但是提高了性能
  - 淘宝、天猫上线，把 oracle 官方 JVM 版本全部替换

- Dalvik VM

  - 谷歌开发，应用于 Android 系统，安卓 2.2 提供了 JIT，发展迅猛
  - 只能称作虚拟机，不能称作 Java 虚拟机，没有遵循 Java 虚拟机规范
  - 不能直接执行 Java 的 Class 文件
  - 基于寄存器架构，不是 jvm 的栈架构
  - 执行的是编译后的 dex 文件，执行效率比较高
  - 安卓 5.0 使用支持提前编译 AOT 的 ART VM 替换 Dalvik VM

- Grall VM
  - 2018 年 4 月，Oracle labs 公开了 GraalVM。
  - 跨语言全栈虚拟机，可以作为任何语言的运行平台使用

## 💡 类加载子系统

### 作用

- 负责从各种来源（文件、网络、硬盘...）加载 Class 文件，Class 文件开头有特定标识(0x CA FE BA BE)

- Classloader 只负责 Class 文件的加载，至于是否可运行，则由执行引擎决定

- 加载的类信息存放于称为<font color="#f44336">方法区（元空间、永久代）</font>的内存空间；除了类信息，方法区还会存放<font color="#f44336">运行时常量池</font>信息，还可能包括字符串字面量和数字常量
  - 常量池运行时加载到内存中，即运行时常量池

### 💡 角色

- 类比 DNA 模板加载出蛋白质的过程：.class 文件就是纯粹概念上的 ACGT 碱基对排列，通过聚合酶（ClassLoader）放入细胞核即为 DNA 模板（clazz），再通过模板 DNA 表达制造多种功能的蛋白质（类实例化）

![[Pasted image 20230313222459.png]]

### 类的加载过程

1. 加载（是<font color="#ff0000">类加载</font>过程的第一阶段，二者意思不能混淆）

- 通过一个类的全限定名 Fullname 获取定义此类的<font color="#ff0000">二进制字节流 bytes[]</font>，来源可以是：

  - 本地磁盘获取
  - 网络获取，Web Applet
  - zip 压缩包获取，jar，war
  - 运行时计算生成，动态代理
  - 有其他文件生成，jsp
  - 专有数据库提取.class 文件，比较少见
  - 加密文件中获取，防止 Class 文件被反编译的保护措施

- 将这个字节流所代表的的静态存储结果转化为<font color="#f44336">方法区</font>的运行时数据结构
- 在<font color="#f44336">堆内存中生成</font>一个代表这个类的 java.lang.<font color="#f44336">Class 对象</font>，作为方法区这个类的各种数据访问入口

2. 链接

- 2.1 验证(-Xverify:none 可关闭)

  - 确保 Class 文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全

  - 四种验证

    - 文件格式验证

      - CA FE BA BE(魔数，Java 虚拟机识别)
      - 主次版本号
      - 常量池的常量中是否有不被支持的常量类型
      - 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量

    - 元数据验证

      - 对字节码描述的信息进行语义分析，保证描述符合 Java 规范
      - 类是否有父类，除了 Object 之外，所有的类都应该有父类
      - 类的父类是否继承了不允许被继承的类（被 final 修饰的类）
      - 如果这个类不是 抽象类，是否实现了其父类或接口中要求实现的所有方法。
      - 类的字段，方法是否与父类的产生矛盾。例如方法参数都一样，返回值不同

    - 字节码验证

      - 通过数据流分析和控制流分析，确定程序语义是合法的，符合逻辑的。
      - 对类的方法体，进行校验分析，保证在运行时不会做出危害虚拟机的行为
      - 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，不会出现类似于在操作数栈放了一个 int 类型的数据，使用时却按照 long 类型加载到本地变量表中的情况。
      - 保障任何跳转指令都不会跳转到方法体之外的字节码指令上。

    - 符号引用验证
      - 通过字符串描述的全限定名是否能找到对应的类
      - 符号引用中的类、字段、方法的可访问性是否可被当前类访问

- 2.2 准备

  - 为类(static)变量分配方法区内存，并且默认初始化

![[Pasted image 20230313222648.png]]

    - 不包含常量(final static)，因为常量在编译的时候就会分配内存了
    - 不会为实例变量分配内存，实例变量会随着对象的创建(new、newInstance())一起分配到 Java 堆内存中

- 2.3 <font color="#ff0000">解析</font>（静态解析、动态链接）

  - 将常量池内的符号引用转换为直接引用的过程
  - 解析操作可以在初始化后再执行（指多态动态绑定动态链接）
  - <font color="#ff0000">符号引用</font>就是方法的坐标: 一组（`[#数字=类型 tag]：[#数字...]`），用字符串符号来描述引用的目标，无法被 JVM 直接使用

    - 编译过程中，JVM 不知道目标方法的具体内存地址。因此，编译器会暂时用符号引用来表示该目标方法。
    - 符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符。
    - <font color="#ff0000">静态解析的直接引用</font>就是直接指向目标地址的指针，相对偏移量或一个间接定位到目标的句柄，能被 JVM 直接使用
    - 解析动作主要针对常量池中符号引用的 tag：CONSTANT_Class_info（类，接口），CONSTANT_Fieldref_info（字段，仅静态解析），CONSTANT_Methodref_info（类方法，接口方法)
    - ![[Pasted image 20230313222720.png]]

  - 动态链接的直接引用是该类的虚方法表的索引
    - 虚方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的方法
    - 子类虚方法表中是父类虚方法表中的所有方法的超集
    - 子类方法在虚方法表中的索引值，与它所重写的父类方法的索引值相同
    - 这样约定是为了方便实现方法重写, 按就近原则递归地找可执行父类方法
    - ![[Pasted image 20230313222956.png]]
  - 静态解析是方法重载的基础, 动态链接是方法重写的基础, 两者分别实现了编译时多态和运行时多态

3. （类）初始化 class-init

   - 初始化阶段是执行 static 类构造器方法\<clinit\>()的过程, 并为常量显式初始化
   - 此方法不需要定义，是 javac 编译器<font color="#ff0000">按顺序收集</font>类中的所有 static 类变量的赋值动作和静态代码块中的语句合并而来

     - 非法的前向引用问题（静态变量定义在静态代码块后，静态代码块中可以赋值，因为准备阶段在链接时就已赋默认值，但禁止引用静态变量）

   - \<clinit\>()不同于隐式无参或显式的类构造器（关联：类构造器是虚拟机视角下的\<init\>()），其只为 static 变量和代码块显式初始化而生。如果没有 static 类变量和静态代码块，也不会有 clinit。

   - 若该类具有父类，JVM 会保证子类的\<clinit\>()执行前，父类的\<clinit\>()已经执行完毕

   - JVM 必须保证一个类的\<clinit\>()方法在多线程下被同步加锁，如果多线程同时试图加载同个一类，只有单线程会抢到锁，其他都被阻塞。体现在 ClassLoader 的 loadClass 方法中：synchronized (getClassLoadingLock(className)) {...}。这保证了类在内存中只有一份 Class 模板对象，即所谓类只加载一次

4. 使用
5. 卸载

6. 补充说明：

- 加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。
- 解析阶段不一定，在某些情况下可以在初始化阶段之后再开始，为了支持 Java 语言的运行时绑定特性（动态绑定）
- Java 虚拟机规范严格规定了，有且只有<b><font color="#ff0000">六种情况，必须立即对类进行初始化</font></b>：

  - 1、遇到<font color="#ff0000">new</font>，get<font color="#ff0000">static</font>，putstatic 或 invokestatic 这四条字节码指令时(创建实例+调用静态变量/方法)。

    - 使用 new 关键字实例化对象
    - 读取或设置一个类型的静态字段（final 修饰已在编译期将结果放入常量池的静态字段除外）
    - 调用一个类型的静态方法的时候

  - 2、对类型进行<font color="#ff0000">反射</font>调用，如果类型没有经过初始化，则需要触发初始化
  - 3、<font color="#ff0000">初始化子类</font>的时候，发现父类没有初始化，则先触发父类初始化
  - 4、<font color="#ff0000">虚拟机启动</font>时，用户需要指定一个要执行的主类（包含 main 方法的那个类），虚拟机会初始化这个主类
  - 5、（jdk7）如果一个 java.lang.invoke.MethodHandler 实例最后的解析结果为 REF_getStatic,REF_putStatic,REF_invokeStatic，REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法对应的类没有进行初始化，则先触发其初始化
  - 6、（jdk8）当一个<font color="#ff0000">接口</font>中定义了<font color="#ff0000">default 方法</font>时，如果这个接口的实现类发生了初始化，要先将接口类进行初始化

- 除了以上几种情况，其他使用类的方式被看做是对类的被动使用，都不会导致类的初始化

### 类加载器分类（1 主+3 副）

- 启动类加载器和自定义加载器

  - JVM 规定，将所有 extends 抽象类 ClassLoader 的类加载器(即除 Bootstrap 外所有)都划分为自定义加载器

    - ![[Pasted image 20230313223424.png]]

    - ![[Pasted image 20230313223430.png]]

- 代码样例，获取类加载器

  - ![[Pasted image 20230313223438.png]]

- 启动类加载器 Bootstrap

  - C 编写，嵌套在 JVM 内部

  - 用来加载 Java 核心类库：rt.jar，resources.jar，sun.boot.class.path 路径下的内容

  - 并不继承 java.lang.ClassLoader，没有父 类加载器

  - 加载扩展类和应用程序类加载器，并指定为他们的父（顶级）类加载器

  - 出于安全考虑，Bootstrap 启动类加载器只加载包名为 java\javax\sun 等开头的类

- 扩展类加载器

  - Java 语言编写，由 sun.misc.Launcher$ExtClassLoader 实现

  - 继承于 ClassLoader 类

  - 父 类加载器指定为启动类加载器

  - 从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 jre/lib/ext 子目录下加载类库

    - ![[Pasted image 20230313223447.png]]

  - 如果用户创建的 jar 包放在 jre/lib/ext 下，也会被 ExtClassLoader 加载

- 应用程序类加载器（系统类加载器）

  - Java 语言编写，由 sun.misc.Launcher$AppClassLoader 实现

  - 派生于 ClassLoader 类

  - 父 类加载器为扩展类加载器

  - 负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库

  - 该类加载器是程序中默认的入口类加载器（双亲委派从此处开始）

  - 一般来说，用户自定义类都是由它来完成加载（除非放到 ext 文件夹）

  - 通过 ClassLoader#getSystemClassLoader（）方法可以获取到此类加载器

- 用户自定义类加载器

  - 为什么要用自定义类加载器？优势？

    - 隔离加载类

      - 使中间件的 Jar 包与框架的 Jar 包不发生冲突（比如在一个 Tomcat 上部署多个项目，项目间 jar 包名称冲突；Guava 存在不同版本同名 jar 包依赖）

    - 修改类加载的方式

      - 启动类加载器必须使用，其他可以根据需要自定义加载

    - 扩展加载源（不仅来自于硬盘、网络的 class 字节码，还可拓展到物联网）

    - 防止源码泄露

      - 对字节码进行加密，在自定义类加载器实现解密

  - 实现步骤

    - 继承抽象类 java.lang.ClassLoader 类的方式，实现自己的类加载器

      - 方法 1：继承并重写 loadClass 方法（可以破坏双亲委派）

      - 方法 2：继承并重写 findClass 方法（无法破坏双亲委派）

    - 如果没有太过复杂的需求，可以直接继承 URLClassLoader 类，可以避免自己编写 findClass（）方法，及其获取字节码流的方式，使自定义类加载器编写更加简洁

- 关于 Abstract ClassLoader

  - 是一个抽象类，除了启动类加载器，其他类加载器都继承自他

  - ![[Pasted image 20230313223459.png]]

### 双亲委派（通过 ClassLoder 的 loadClass 方法体现，职责链设计模式）

- 原理

  - 1、如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父 类加载器去执行

  - 2、父 类加载器还存在其父 类加载器，进一步向上委托，依次递归，请求最终将达到顶层的启动类加载器（Bootstrap 一定过目）

  - 3、如果父 类加载器可以完成请求类加载任务，就成功返回；否则，子加载器才会尝试自己去加载

  - 比如：自定义一个类 java.lang.String，在创建该类实例时，Bootstrap 过目发现能加载名为 String 的核心类，于是直接加载核心类 String。

  - 这就防止自定义类造成破坏：假如自定义 String 类中包含核心 String 没有的方法或属性，那么报错找不到此方法。

- 优势

  - 避免类的重复加载

  - 保护程序安全，防止核心 API 被篡改

- <font color="#ff0000">自定义类加载器</font>可以<font color="#ff0000">破坏双亲委派机制</font>：

  - 需求: 有时确实需要同名类重复加载, 比如 Tomcat 容器中不同服务可能依赖于同一组件的不同版本

  - 继承 ClassLoader，重写 loadClass 方法即可。如果仅重写 findClass 方法还是会调用默认的 loadClass，则无法打破。

  - 实例 1：<https://blog.csdn.net/qq_38182963/article/details/78660779>

  - 实例 2：<https://blog.csdn.net/admin522043032/article/details/121824885>

- 沙箱安全机制

  - 保证对 Java 核心类源代码的保护，使自定义 java、javax 开头的类失效报错

### 补充

- 在 JVM 中表示两个 class 对象是否为同一个类，存在两个必要条件<br>

  - 完整类名必须一致，包括包名（com.xtd.String≠java.lang.String）

  - 加载这两个类的 ClassLoader 必须相同

- JVM 必须知道一个类型是由启动类加载器加载的，还是由自定义加载器加载的。如果是自定义加载器加载的，JVM 会将这个类加载器的一个引用作为类型信息的一部分，保存到方法区中。

## 运行时数据区概述

- ![[Pasted image 20230313223530.png]]

- 下图中，红色的<font color="#ff0000">堆外内存(方法区、元空间、永久代)、堆</font>为 JVM 进程独享（表现为 Runtime 类的唯一单例）、各线程共享，灰色的 PC/NMS/VMS 为各线程独享
- ![[Pasted image 20230313223555.png]]

- GC 主要执行在堆上，如果回收不当，就会造成 OOM，因此需要 GC 优化

- 元空间容量为堆外剩余的所有系统内存，一般不会 OOM，少数情况也需 GC 优化

- 栈 VMS/NMS 的操作只有出入栈（意味着栈空间是被紧凑利用的，64 位默认容量是 1MB）；PC 过小；两者不会产生零碎空间，没有 GC 优化。但栈仍可能 OOM 或 SOF

  - 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常（新栈 nested 过多）

  - 如果虚拟机栈可以动态扩展（当前大部分的 Java 虚拟机都可动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的系统内存时会抛出 OutOfMemoryError 异常。（旧栈扩容过大）

  - 与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。

![[Pasted image 20230313223628.png]]

## 程序计数器（PC 寄存器）

- 运行时数据区中唯一不会出现 OOM 的区域，只记录一条地址，没有垃圾回收

- 每个线程有一个独立的 PC，线程之间 PC 互不影响

- 当前线程所执行的字节码的行号指示器（钩子），指向下一条指令的地址，然后执行引擎根据 PC 读取下一条指令

- 如果线程执行 Java 方法，则计数器记录正在执行的虚拟机字节码的指令的地址

- 如果正在执行本地 native 方法，这个计数器值则应为空。（undefined）

![[Pasted image 20230313223700.png]]

- 用 PC 存字节码指令地址作用？为什么用 PC 存线程的执行地址？

> 为了线程切换后能恢复到正确的下一条执行位置，保存现场

- 为什么 PC 线程独有不共享？

> 假如有 3 个线程共享 1 个 PC，123 轮流执行，执行完 3 切回 1 时，PC 存的是 2 的下一条指令地址，错误

## 💡💡 虚拟机栈 VMS

### 内存中的栈与堆

- 栈是运行时的单位，而堆是存储的单位。

  - 栈解决程序如何<font color="#ff0000">按序</font>执行，如何<font color="#ff0000">按序</font>处理数据

  - 堆解决的是数据高效存储问题。

### 基本内容

- 每个线程创建时都会创建一个私有的 VMS，VMS 内部保存一个个栈帧，对应着一次次的方法调用。栈顶帧对应当前方法。

- VMS 生命周期和线程一致

- 主管 Java 程序的运行，保存方法的局部变量（8 种基本数据类型+对象的引用地址），部分结果，并参与方法的调用和返回。

  - 局部变量 vs 成员变量

  - 基本数据类型 VS 引用类型变量（类，接口，数组）

### 优点

- 快速有效的存储方式，访问速度仅次于 PC

- JVM 对 VMS 的操作只有两个：

  - 执行方法，push 栈帧

  - 方法执行结束，pop 栈帧

- 栈操作是紧凑的，不存在 GC，但是存在 OOM 和 SOF：

  - Java 栈大小是动态或者固定的

  - 如果是固定（如 Hotspot），线程请求的栈容量超过固定最大值，则 StackOverflowError

  - 如果是动态扩展，线程请求的栈容量超过最大值则申请扩容，无法申请到足够的系统内存则 OOM；

- 使用-Xss1024K，设置线程的最大栈空间

  - ![[Pasted image 20230313223847.png]]

### 栈的存储单位

- 每个线程都有自己私有的栈，栈中的数据以栈帧为基本单位存储

- 线程上正在执行的每个方法都各自对应一个栈帧, 栈帧描述方法的状态

- 一条活动的线程中，某时刻，只会有一个活动的栈顶帧

- 执行引擎运行的所有字节码指令只针对当前栈顶帧进行操作

- 如果方法中调用了其他方法，对应新的栈帧会被创建出来，放在顶端，成为新的当前帧

- ![[Pasted image 20230313223854.png]]

### 栈运行原理

- 不同线程中包含的栈帧不允许直接相互引用

  - 但可以通过堆变量桥接, 比如 InheritableThreadLocal 和 TTL

- 当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给压着的栈帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为新的栈帧。

- Java 方法有两种返回方式，不管哪种方式，都会导致栈帧被弹出

  - 一种是正常的函数返回，使用 return 指令

  - 另外一种是抛出异常

### 栈的内部结构

- 局部变量表占大头，很大程度决定一帧大小，即该线程的 VMS 能容纳多少帧

  - 因此写递归时尽量抽取出成员变量, 缩小形参数量, 防止栈 OOM 或 SOF

- 💡 局部变量表（slot 数组）

  - 定义为一个数字数组，主要用于存储方法的 ① 入参（包括隐式传入的 this）、② 方法体内定义的局部变量。元素类型包括 8 种基本数据类型，对象引用，以及 return address 类型

  - 局部变量表建立在线程的栈上，是线程私有的，不会成为共享资源，因此不存在数据安全问题

  - 局部变量表占用空间是在编译期确定下来的，运行期不变

  - 最基本的存储单元是 slot

    - 32bit 数据类型占用一个 slot，64bit 类型（long 和 double）占用两个 slot

    - JVM 虚会为局部变量表中的每个 slot 都分配一个访问索引，通过这个索引即可访问到局部变量表中指定的元素

    - 如果当前帧是由构造方法或者实例方法创建的，那么该对象引用 this，会存放在 index 为 0 的 slot 处，其余的参数表顺序继续排列。

      - ![[Pasted image 20230313223908.png]]<br>

      - ![[Pasted image 20230313223915.png]]

    - 局部变量表中的 slot 是可以重复利用的，如果一个局部变量过了其作用域，那么其作用域之后声明的新的局部变量就有可能会复用过期局部变量的 slot，从而节省资源

  - 方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁

  - 静态变量与局部变量对比及小结

    - 变量的分类

      - 按照数据类型分

        - 基本数据类型

        - 引用数据类型

      - 按照声明的位置

        - 成员变量，在使用前经历过初始化过程

          - 类变量 static

            - 链接的准备阶段给类变量默认赋值；初始化阶段显式赋值，即静态代码块赋值

          - 实例变量

            - 随着对象的创建，会在堆空间分配实例变量空间，并进行默认赋值

        - 局部变量

          - 在使用前，必须进显式赋值，否则编译不通过（没有默认赋值！）

  - 补充：

    - 在栈帧中，<font color="#f44336">与性能调优关系最密切的部分，就是局部变量表</font>，方法执行时，虚拟机使用局部变量表完成方法的传递

    - 局部变量表中的变量是重要的 GC 根节点，只要<font color="#f44336">正在</font>被局部变量表中元素直接或间接引用的对象，都不会被回收（<font color="#0000ff">可达性分析</font>）

- 💡 操作数栈（数组模拟的 stack）

  - 在方法执行的过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈/出栈

    - ![[Pasted image 20230313223933.png]]

  - 如果被调用方法带有返回值的话，其<font color="#ff0000">返回值将会被压入当前栈帧的操作数栈中</font>，并更新 PC 中下一条需要执行的字节码指令

  - JVM 的解释引擎是<font color="#f44336">基于栈的执行引擎</font>，其中<font color="#f44336">“栈”就是操作数栈</font>

  - 主要用于<font color="#ff0000">保存计算过程的中间结果</font>，同时作为计算过程中变量临时的存储空间

  - 当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个栈帧的操作数栈<font color="#f44336">是空的</font>

  - 每一个操作数栈会拥有一个明确的最大栈深度，在编译期就定义好

  - 类似 slot，32bit 类型占用一个栈单位深度，64bit 类型占用两个栈单位深度

  - 操作数栈虽然实现方式是数组，但不能采用访问索引方式进行数据访问，而是只能通过标准的入栈、出栈操作完成一次数据访问

  - 栈顶缓存技术 ToS

    - 由于操作数栈存储在内存中，频繁进行内存读写操作会影响执行速度（即基于栈的 VM 速度\<基于寄存器）。

    - 将栈顶元素全部缓存到 CPU 的寄存器中（模拟基于寄存器的 VM），以降低内存的读写次数，提升执行引擎的执行效率

- 动态链接

  - ![[Pasted image 20230313223940.png]]

  - 在类加载后，将运行时常量池中的符号引用，转化为直接引用的过程。

    - 每一个栈帧内部，都包含一个引用，它指向运行时常量池表中的一项，表示该帧所属方法（一个"#数字=类型 tag：方法名“字符串符号引用）
    - ![[Pasted image 20230313223951.png]]

    - 目的是为了支持当前方法的代码能够实现动态链接，比如方法 B 调用方法 A，执行 invokevirtual ”#07“ 指令：

    - ![[Pasted image 20230313223956.png]]

    - ![[Pasted image 20230313224000.png]]

    - ![[Pasted image 20230313224003.png]]

    - 在.java 源文件被编译成字节码.class 文件时，所有的变量、方法引用都作为符号引用，保存在.class 文件的运行时常量池中

    - 描述一个方法调用其他方法，就是通过常量池中指向方法的符号引用来表示的。

  - 常量池、运行时常量池

    - 常量池在字节码文件中，运行时常量池在运行时的方法区中

    - 常量池的作用：提供符号引用和字面量，方便 invoke 等指令调用

- 方法的调用

  - 静态解析

    - 当一个字节码文件被装载进 JVM 内部时，进行链接时，如果<font color="#ff0000">被调用的目标方法在编译期可知，且运行时期间保持不变</font>，这种情况下将调用方法的符号引用转为直接引用的过程称为静态解析

  - 动态链接

    - 如果被调用的方法<font color="#ff0000">无法在编译期确定</font>，只能在运行期将调用的方法的符号引用转为直接引用，这种引用转换过程具备动态性，因此被称为动态链接

  - 方法的绑定

    - 绑定是一个字段、方法、或者类在符号引用被替换为直接引用的过程。仅仅发生一次。

    - 早期绑定（对应静态解析）

      - 被调用的目标方法如果再编译期可知，且运行期保持不变

    - 晚期绑定（对应动态链接）

      - 被调用的方法在编译期无法被确定，只能够在程序运行期根据实际的类型绑定相关的方法。

  - Java 中任何一个普通方法都具备虚函数的特征（默认使用 invokevirtual 调用，运行期确认，具备晚期绑定的特点）

  - 如果不希望某个方法拥有虚函数的特征，则可以使用关键字 final/private/static 来标记这个方法

  - 虚方法和非虚方法

    - 非虚方法

      - 如果方法在编译期就确定了具体的调用版本，则这个版本在运行时是不可变的。这样的方法称为非虚方法

      - 不能体现多态（继承+重写）都是非虚方法：

        - 静态方法（可被继承，不可重写，只属于 Class 类，不属于对象，因而在编译期就能确定）

        - 私有方法（不可继承，只有父类可见，子类不可见，因而在编译期就能确定）

        - final 方法（可被继承，但子类只能调用，无法被重写）

        - 实例构造器（构造器要与类同名，子类与父类不重名，不可继承，只能通过 super()调用）

        - 父类方法（单继承机制，子类通过 super. 调用父类方法是唯一确定的）

    - 其他方法称为虚方法

  - 方法调用指令

    - 普通调用指令

      - <font color="#0000ff">invokestatic</font>调用静态方法，解析阶段确定唯一方法版本

      - <font color="#0000ff">invokespecial</font>调用\<init\>方法（包括 this()和 super()），私有及 super.父类方法，解析阶段确定唯一方法版本

      - invokevirtual 调用所有虚方法（除 final，final 因为历史原因设计成 invokevirtual）

      - invokeinterface 调用接口方法（实现方法不能在编译期确定）

      - 其中 invokestatic 指令和 invokespecial 指令调用的方法称为非虚方法，其余的指令调用方法（invokevirtual 中 final 修饰的除外）称为虚方法

    - 动态调用指令 JDK1.7 新增

      - invokedynamic

        - 动态解析出需要调用的方法，然后执行

      - 直到 Java8 的 Lambda 表达式的出现，invokedynamic 指令的生成，在 Java 中才有了直接的生成方式

        - ![[Pasted image 20230313224020.png]]

    - 静态语言和动态语言

      - 区别在于对类型的检查是编译器还是运行期，满足编译期就是静态类型语言，反之就是动态类型语言。

      - Java 是静态类型语言，动态调用指令增加了动态语言的特性

  - 方法重写的本质

    - 找到操作数栈顶的第一个元素所执行的对象的实际类型，记做 C

    - 如果在类型 C 中找到与常量池中描述符和简单名称都相符的方法，则进行访问权限校验：

      - 如果通过，则返回这个方法的直接引用，查找过程结束

      - 否则，返回 java.lang.IllegalAccessError 异常。这个错误一般引起编译器异常，如果发生在运行时，说明通过反射访问了私有方法

    - 否则，按照继承关系从下往上依次对 C 的各个父类进行上一步的验证过程。

      - 在类加载-\>链接的解析阶段, 规定指向这些方法的索引值都是相同的

      - 因此类似双亲委派机制, 使用递归调用实现对父类被重写方法的验证

    - 如果始终没有找到合适的方法，说明找到了没有重写的抽象 abstract 方法，则抛出 java.lang.AbstractMethodError 异常

  - 虚方法表

    - 面向对象的编程中，会很频繁的使用动态分配，如果每次动态分配的过程都要重新在类的方法元数据中搜索合适的目标的话，就可能影响到执行效率，因此为了提高性能，JVM 采用在类的方法区建立一个虚方法表，使用索引表来代替查找

    - 每个类都有一个虚方法表，表中存放着各个方法的实际入口

    - 虚方法表会在类加载的链接阶段被创建，并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法也初始化完毕

      - ![[Pasted image 20230313224030.png]]

- 方法返回地址

  - 存放调用该方法的 PC 寄存器的值

  - 方法的结束

    - 正常执行完成

    - 出现未处理异常，非正常退出

  - 无论哪种方式结束，都会返回该方法被调用的位置。

    - 方法正常退出时，<font color="#ff0000">调用者的 PC 寄存器的值作为返回地址，即调用该方法的指令的下一条指令的地址</font>。

    - 异常退出的，返回地址是通过<font color="#ff0000">异常表</font>来确定，栈帧中一般不会保存这部分信息

  - 执行引擎遇到任意一个<font color="#0000ff">方法返回的字节码指令</font><font color="#000000">，</font>会有返回值传递给上层的方法调用者，简称正常完成出口

    - ireturn -\> 方法返回值是 boolean，byte，char，short，int

    - lreturn -\> long

    - freturn -\> float

    - dreturn -\> double

    - areturn -\> 引用类型

    - return -\> void 的方法、实例初始化方法\<init\>、类和接口的初始化方法\<clinit\>

  - 本质上，方法的退出就是当前栈顶帧的出栈过程。此时需要恢复上层方法的局部变量表，操作数栈，将返回值压入调用者栈帧的操作数栈，设置 PC 寄存器值等，让调用者方法继续执行下去。

  - 正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值

### Q & A

- 栈内存分的越大越好？

> 总内存有限，VMS 是线程私有的，VMS 越大线程数越少

- 可以使用 GC 优化 VMS？

> VMS 操作紧凑，不用 GC

- 举例 VMS 溢出情况？

> 固定 SOF，可变 OOM

- 开发中遇到哪些异常？

> 5 种 OOM+SOF，ConcurrentModifyException

- 方法内联为什么能优化？

> 方法调方法涉及栈帧压弹，可能导致压弹操作的 overhead\>业务逻辑，因此将被调用方法写入为调用者的一部分，省去压弹栈帧操作 overhead。

- 方法内定义的局部变量一定线程安全？

> 不一定，比如方法内定义了线程不安全的局部变量，并返回，返回的变量可能被其他线程改变[<font color="#0000ff">逃逸分析</font>]

- -XX:+PrintCompilation 打印 JIT 编译日志
- -XX:+UnlockDiagnosticVMOptions
- -XX:+PrintInlining 打印内联信息

## 本地方法接口 Java Native Interface JNI

- 本地方法是一个 Java 调用非 Java 代码的接口，比如 C/C++

- native 与 abstract 不共存

- 为什么使用 native method
  - 与 Java 环境外交互
    - 例如与操作系统底层或硬件交换信息时的情况
    - 例如启动一个线程 start0

## 本地方法栈 NMS（基于 Hotspot）

- VMS 管理 Java 方法的调用，而 NMS 用于管理 Native 方法的调用

- NMS 也是线程私有的

- 允许被实现成固定或者是可动态扩展的内存大小，内存溢出情况和 Java 虚拟机栈相同 SOF+OOM

- 使用 C 语言实现

- 具体做法是 NMS 中登记 native 方法，在执行引擎执行时加载到本地方法库

- 当某个线程调用一个本地方法时，就会进入一个新的，不受虚拟机限制的环境，它和 JVM 拥有同样的权限

- 并不是所有的 JVM 都支持本地方法，因为 JVM 规范没有明确要求 NMS 的使用语言，具体实现方式，数据结构等

- Hotspot 中，直接将 NMS 和 VMS 合二为一

## 💡💡💡 堆

### 堆的核心概述

- 一个 Java 进程 ↔ 一个 JVM 单例 Runtime（饿汉式） ↔ 一个堆内存+方法区，进程中的多线程 ↔ 多个 PC、VMS、NMS，前者供后者共享使用

- Java 堆区在 JVM 启动（类加载器启动）的时候即被创建，其空间大小在运行时保持不变。堆内存的大小是可预先静态设置的：-Xms10m 初始堆空间 10MB； -Xmx10m 最大堆空间 10MB

- 堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。

- 所有的线程共享 Java 堆，堆还可以划分出线程私有的缓冲区（TLAB）

  - 堆空间一定是线程共享？为什么设置 TLAB？

  > TLAB 不共享。假如堆全共享，并发性会降低。

- “<font color="#ff0000">几乎</font>”所有的对象实例都在运行时分配堆内存（也有可能在栈上局部变量）

- 数组和对象“<font color="#ff0000">可能</font>”永远不会存储在栈上，因为栈帧中局部变量表保存引用，引用指向对象或者数组在堆中的位置

```java
Object s1 = new Object(); Object s2 = new Object();
```

![[Pasted image 20230313224334.png]]

- 方法结束后，栈顶帧出栈，局部变量表随之销毁，指向堆中对象实例的引用也一同销毁。但堆中的对象<font color="#ff0000">不会马上被移除</font>，而是成为垃圾，仅在可用堆内存不足 GC 时，被<font color="#ff0000">GC 识别为垃圾才会真正移除</font>。

  - 为什么不立马 GC？

  > 栈操作频率高，如果堆与其同步操作，则系统给 GC 的开销大，用户性能差

- 堆是 GC 执行垃圾回收的重点区域，主要解决频繁 GC，大内存占用（方法区也存在一些 GC）

- 堆空间逻辑上细分为：

  - ![[Pasted image 20230313224350.png]]

  - 年轻代 = 伊甸园 + 幸存 0 + 幸存 1

  - 老年代

  - 方法区（jdk1.8 以前叫永久代，之后叫元空间）

  - ![[Pasted image 20230313224356.png]]

- -XX:+PrintGCDetails 可开启打印查看方法区实现

### 设置堆内存的大小与 OOM

- -Xms ：堆空间的起始内存 start memo。

- -Xmx：堆空间的最大内存 max memo，<font color="#ff0000">超过最大内存将抛出 OOM</font>

- 手动设置时，通常-Xms == -Xmx，因为向上扩容到 Xmx 和 GC 释放内存到 Xms 都需要占用系统资源

- 默认情况下，堆空间分配：

  - 初始内存大小 =物理电脑内存 / 64

  - 最大内存大小 =物理电脑内存 / 4 = Xms \* 16

  - ![[Pasted image 20230313224408.png]]

- jps 命令 查看当前程序运行的进程号

- jstat 命令 查看 JVM 在 gc 时的统计信息 jstat -gc 进程号

### 年轻代与老年代

- Java 对象划分为两类：生命周期短的和长的（比如数据库连接池），生命周期越长，越从 Eden-\>from\<=\>to-\>old，GC 越少；反之越短，GC 越频繁

- 新生代与老年代空间默认比例 1:2，除非可预见生命周期长的对象非常多，老年代需要调高，一般不动此比例

  - -XX:NewRatio=xx 表示新生代占 1，老年代占 xx

  - -Xmn：设置新生代最大内存大小，如果同时设置了 XX:NewRatio 与此参数冲突，则以此参数为准。

- jinfo -flag 参数名 进程号，查看参数设定值

- 在 HotSpot 中规定，Eden 空间和另外两个 Survivor 空间缺省所占的比例是：8:1:1

  - -XX:SurvivorRatio=xx 表示 Eden 占 xx，双 Survivor 共占 1，最小为 512K

  - 实际是 6:1:1，因为默认开启了自适应内存分配

    - -XX:-UseAdaptiveSizePolicy："-"表示关闭自适应，实际没有用。直接强制用 XX:SurvivorRatio 分配即可

- <font color="#ff0000">”几乎“</font>所有的 Java 对象都是在 Eden 区被 new 出来的

  - Eden 放不下的大对象，直接晋升老年代

### 图解对象分配过程

- 1、new 的对象如果能在 Eden 放得下，先放在 Eden 区；如果放不下，且 yGC 将 Eden 全转移后仍放不下，视为超大对象，直接晋升老年代

- 2、当 Eden 空间已满时，再创建新对象，会触发 Minor GC（Young GC），STW 停止用户线程，依次判断 Eden 中的对象，将不再被其他对象引用的对象（垃圾）进行销毁，再加载新的对象放到 Eden 区，新对象分带年龄 age=0

- 3、经过 2 后，将 Eden 中剩余未销毁的原对象复制到幸存者 0 区，幸存者 age++。如果复制过来的对象放不下幸存者区，视为超大对象，提前晋升老年代

- 4、若再次触发 Minor GC，此时放在幸存者 0 区的对象，如果仍未回收，就会同新对象一同复制到幸存者 1 区，age++

- 5、若再次触发 Minor GC，又会将幸存者重新复制到幸存者 0 区，依次 0101 循环

- 6、直到某次 GC 时，发现某幸存者区中存在分代年龄 age=15 的对象，则会将这些对象转移去老年区

  - -XX:MaxTenuringThreshold=N 进行设置

- ![[Pasted image 20230313224422.png]]

- 总结：

  - 针对幸存者 s0，s1 区：复制之后有交换，谁空谁是 to

  - GC 频繁在新生代收集，很少在老年代收集，几乎不在永久代/元空间收集

### 对象分配特殊过程

- ![[Pasted image 20230313224428.png]]

- 触发 YGC，新生代就会进行回收，注意新生代<font color="#ff0000">无法主动请求回收</font>

- 超大对象 eden 放不下或 to 区放不下，就要看老年代是否可以放下，也放不下，需要 FullGC（或者 MajorGC）

- FGC 后老年代也放不下，OOM

### MinorGC，MajorGC，FullGC

- GC 按照内存回收区域分为：

  - 部分收集（PartialGC）

    - MinorGC （YoungGC），针对新生代=Eden+S01

    - MajorGC（OldGC），针对老年代

      - 目前只有<font color="#ff0000">CMS</font>会<font color="#ff0000">单独收集老年代</font>，其他 OldGC 会同时触发 YGC, 因此常合称 FGC

    - 混合收集（<font color="#ff0000">仅 G1 采用</font>），针对<font color="#ff0000">整个新生代以及部分老年代</font>的垃圾

  - 整堆收集（FullGC），针对<font color="#ff0000">整个 Java 堆和方法区</font>的垃圾收集

- 新生代 MinorGC 的触发条件

  - 当 Eden 区空间不足时，就会触发 MinorGC，<font color="#ff0000">Survivor 区满不会触发 GC，而是当成超大对象进入老年代</font>

    - 如果 Eden 区比例设置过大会怎样？

      > S 区过小，经常满，MinorGC 清出的幸存者全部进入老年代，频繁 FullGC

    - 如果 Eden 区比例设置过小会怎样？

      > 频繁 YGC，STW

  - 因为 Java 对象大多朝生夕灭，所以 MinorGC 非常频繁

  - MinorGC 会引发 STW，暂停用户线程，进行垃圾识别

- 老年代 GC（MajorGC/FullGC）触发条件

  - 指发生在老年代的 GC，对象从老年代消失，我们说“MajorGC”“FullGC”发生了

  - 出现了 MajorGC，经常会伴随至少一次 MinorGC

    - 非绝对，在 Parallel Scavenge 收集器的收集策略里就直接进行 MajorGC 的策略选择过程

    - 也就是老年代空间不足，会先尝试触发 MinorGC，如果之后空间还不足，则触发 MajorGC

  - MajorGC 的速度比 MinorGC 慢 10 倍以上，导致 STW 的时间更长，<font color="#ff0000">应尽量避免</font>

  - 如果 MajorGC 后，内存还不足，就报 OOM

- FullGC 的触发机制

  - 1、调用 System.gc()时，系统建议执行 FullGC，但是不必然执行

  - 2、老年代空间不足

  - 3、方法区空间不足

  - 4、通过 MinorGC 后进入老年代的平均大小，大于老年代的剩余可用内存

  - <font color="#ff0000">FullGC 是开发或调优中尽量要避免的</font>，这样暂停时间会短一些。

- 堆空间分代思想，分代的理由是方便优化 GC 性能，否则每次 GC 检查所有堆空间内对象

### 内存分配策略

- 如果对象在 Eden 出生，并经过第一次 MinorGC 后仍然存活，并且能被 Survivor 区容纳，则被移动到 Survivor 空间中，并将对象年龄设置为 1，对象再 Survivor 区每熬过一次 MinorGC，年龄就+1，当年龄增加到一定程度（默认为 15，不同 Jvm，GC 都所有不同）时，就会被晋升到老年代中

- 新对象优先分配到 Eden

- 大对象直接分配到老年代

  - 尽量避免程序中出现过多的大对象（连续空间对象，比如 byte[] = 大文件, 使用批处理）

- 长期存活的对象分配到老年代

- <font color="#ff0000">动态对象年龄分配</font>

  - 如果 Survivor 区中相同分代年龄的所有对象的空间总和，大于 Survivor 空间的一半，则年龄大于或等于该分代的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄

- 空间分配担保

  - -XX:HandlePromotionFailure

  - 在发生 Minor GC 之前，虚拟机会检查老年代最大可用的连续空间，是否大于新生代所有对象的总空间

    - 如果大于，则此次 MinorGC 是绝对安全的（即使所有新生代无垃圾全部放入老年代）

    - 如果小于，则查看-XX:HandlePromotionFailure 设置是否允许担保失败

      - true

        - 会继续检查老年代最大可用连续空间是否大于<font color="#ff0000">历次晋升</font>到老年代的对象的<font color="#ff0000">平均大小</font>

        - 大于，则认为是经验性安全的，尝试进行一次 MinorGC，但是这次 MinorGC 依然是有风险的

        - 小于，则改为进行一次 FullGC

      - false

        - 则改为进行一次 FullGC

    - jdk7 之后，HandlePromotionFailure 恒定为 true

      - 只要老年代的连续空间大于新生代对象总大小，或者历次晋升的平均大小，就会进行 MinorGC

      - 否则进行 FullGC

### 为线程分配缓冲内存 TLABThread Local Allocation Buffer

- 堆区是多线程共享区域，任何线程都可以访问到堆区的共享数据

- 由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下，从堆区中划分内存空间是线程不安全的。

- 为避免<font color="#ff0000">多个线程在同一地址竞争创建对象</font>，可以使用加锁(给 Eden 上的操作加<font color="#0000ff">乐观锁，CAS+失败重试</font>)等机制，但影响分配速度

- TLAB

  - 从内存模型而不是垃圾收集的角度，对<font color="#ff0000">Eden 区</font>进行划分，JVM 为每个线程分配了一个<font color="#ff0000">私有</font>缓存区域，用于不加锁创建对象（创建完后对象还是线程共享的，”私有“仅针对”创建“这一操作）

  - 多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们将这种内存分配方式称为<font color="#ff0000">快速分配策略</font>

  - openjdk 衍生出来的 JVM 都提供了 TLAB 的设计

    - ![[Pasted image 20230313224524.png]]

  - 补充

    - 尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但是 JVM 确实是将 TLAB 作为内存分配的<font color="#ff0000">首选</font>

    - 开发人员通过-XX:+-UseTLAB 设置是否开启 TLAB 空间

    - 默认情况下，TLAB 空间内存非常小，仅占有整个 Eden 空间的 1%，通过-XX:TLABWasteTargetPercent 设置 TLAB 空间所占用 Eden 空间的百分比大小

    - 一旦对象在 TLAB 空间分配内存失败，JVM 就会尝试<font color="#ff0000">使用加锁机制</font>确保创建操作的原子性，直接在 Eden 空间中分配内存

    - ![[Pasted image 20230313224531.png]]

### 小结堆空间的参数设置

- ![[Pasted image 20230313224537.png]]

### 堆外分配技术

- 随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，<font color="#ff0000">栈上分配、标量替换</font>优化技术，将会导致一些微秒变化，所有对象分配到堆上渐渐变得不那么绝对了。

- 如果经过逃逸分析后发现，一个对象并<font color="#ff0000">没有逃逸出方法</font>的话，那么就可能被优化成栈上分配，这样无需堆上分配，也不需要垃圾回收了，也不用考虑 TLAB 失败后的加锁，是最常见的堆外存储技术

- TaoBaoVM，其中创新的 GCIH（GC invisible heap）技术实现了 off-heap,将生命周期较长的 Java 对象从 heap 中移动 heap 外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的

- 逃逸分析概述

  - 逃逸分析的基本行为就是<font color="#ff0000">分析对象动态作用域</font>

    - 当一个对象在方法中定义后，对象只在方法内部使用，则认为没有发生逃逸

    - 当一个对象在方法中被定义后，它被外部方法引用，则认为发生逃逸，例如作为调用参数传递到方法外

      - ![[Pasted image 20230313224544.png]]

    - jdk7 以后，JIT 编译器自动开启逃逸分析，并根据分析结果决定是否栈上分配

  - 能作为方法内局部变量，就不要定义成方法外类属性，因为属性直到类销毁前都占用堆空间，且不会被 GC 回收；而方法内局部变量，会使堆中对象实例随着栈帧中局部变量表的销毁而变成垃圾，等待被 GC 回收；或对象实例优化定义在栈上，直接随着紧凑的出栈操作销毁，无需 GC。

  - 1.  栈上分配（HotSpot 未采取）

    - 如果 JIT 逃逸分析通过，将对象的堆分配转为栈分配，如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配

  - 2.  同步省略（锁消除）

    - 如果一个对象被发现<font color="#ff0000">只能从一个线程被访问</font>到，对于这个对象的操作可以<font color="#ff0000">不考虑同步</font>

      - JIT 可以借助逃逸分析来判断同步块所使用的同步监视器，是否只能被一个线程访问，而没有被发布到其他线程。

      - 如果没有，那么 JIT 在编译这个同步块的时候，会取消对这部分代码的同步。这样就大大提高并发性和性能，这个取消同步的过程就叫同步省略，也叫锁消除

        - 同步监视器不应定义在方法中，这样做既没意义（多线程调用方法创建多把锁），也会如下被 JIT 优化
        - ![[Pasted image 20230313224601.png]]

  - 3.  分离对象或标量替换（HotSpot 采取）

    - 有的对象可能不需要作为一个连续的内存结构存在，也可以被访问到，那么对象的部分（或全部）可以不存储在堆内存，而是存储在栈中

    - 标量是指一个无法再分解的更小的数据的数据。Java 中 8 种原始数据类型就是标量

    - 可以分解的数据叫聚合量，Java 中的对象就是聚合量，因为他可以分解成其他聚合量和标量

      - ![[Pasted image 20230313224611.png]]

    - 经 JIT 逃逸分析，发现方法内的聚合量对象若不会逃逸，则分解成标量，存储在栈帧的局部变量表里

      - ![[Pasted image 20230313224616.png]]

    - 标量替换参数：-XX:EliminateAllocations，默认打开

## 💡💡 方法区

### 栈、堆、方法区交互关系

- ![[Pasted image 20230313224625.png]]

- ![[Pasted image 20230313224629.png]]

### 方法区的理解

- Java 虚拟机规范中明确说明：尽管所有的方法区在逻辑上是属于堆的一部分，但是一些简单的实现，可能不会选择去进行垃圾收集或者进行压缩。对于 HotSpot 而言，方法区还有一个别名叫 Non-Heap（非堆），目的就是要和堆分开（堆存对象，方法区存 Class 模板）

- 所以方法区看作是一块独立于 Java 堆的内存空间

- 方法区和 Java 堆一样，是各个线程共享的内存区域

- 方法区内存在 JVM 启动的时候被创建，在 JVM 关闭时释放，并且它的实际的物理内存空间和 Java 堆区一样，都是可以不连续的

- 方法区的大小和堆空间一样，可以选择固定大小或者可扩展

- 方法区的大小<font color="#ff0000">决定了系统可以保存多少个类</font>，如果定义太多类，虚拟机同样会抛出内存溢出 OOM：PermGen space 或者 Metaspace

  - 加载大量的第三方的 Jar 包

  - Tomcat 部署过多工程（30~50）

  - 大量生成反射类（动态代理）

### HotSpot 中方法区的演进

- 在 jdk7 及以前，习惯上把方法区，称为永久代，jdk8 开始，使用元空间取代了永久代

  - 元空间和永久代，都是对 JVM 规范定义的方法区的实现。不过元空间与永久代最大的区别在于：元空间不受 JVM 设置内存限制，而是使用系统本地内存，更不易 OOM

  - 根据 Jvm 规范，如果方法区无法满足新的内存分配需求，将抛出 OOM 异常

- jvm 规范对如何实现方法区不做统一要求。例如 BEA JRockit/IBM J9 中不存在永久代的概念（直接存本地，相当于元空间雏形）

- 现在来看，当年使用永久代，限制了方法区大小在 Java 堆上，导致 Java 程序更容易 OOM

  - -XX:MaxPermSize

### 设置方法区大小与 OOM

- <font color="#ff0000">方法区大小不一定是固定的</font>，jvm 可以根据应用动态调整

  - JDK7 及以前

    - 通过-XX:PermSize 来设置永久代初始分配空间，默认值是 20.75M

    - -XX:MaxPermSize 来设定永久代最大可分配空间。

      - 32 位机器默认是 64M

      - 64 位机器默认是 82M

    - 如果 JVM 加载的类信息容量超过了这个值，会报 OOM:PermGenspace

  - JDK8 及以后

    - -XX:MetaspaceSize 初始空间默认 21M

    - -XX:MaxMetaspaceSize 最大空间默认-1 或 inf（一般不动）

    - 如果不指定大小，虚拟机耗光所有可用系统内存，元数据区发生溢出，一样 OOM:Metaspace

    - 对于 64 位 Server JVM，默认的初始元数据区空间为 21M，这就是初始的高水位线。一旦触及这个水位线，<font color="#ff0000">FullGC</font>会触发并卸载没有用的类，然后高水位线会被重置。新的高水位线取决于 FGC 后释放了多少元空间。如果释放空间不足，在不超过最大设定值时，适当提高该值。如果释放空间过多，则适当降低该值。（动态调整）

    - 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次，FullGC 多次调用。为了避免频繁 FullGC，建议<font color="#ff0000">将初始空间-XX:MetaspaceSize 设置为一个相对较高，不会触发 GC</font>的值

### 如何解决 OOM

- 要解决 OOM 异常，一般的手段是通过内存映像分析工具，对 dump 出来的堆转存储快照进行分析。<font color="#ff0000">重点确认内存中的对象是否有必要存活</font>，也就是要先分清楚到底是出现了内存泄露，还是内存溢出

- 如果是内存泄露，可进一步通过工具查看<font color="#ff0000">泄露对象到 GC Roots 的引用链</font>，找到内存泄露对象是通过怎样的路径与 GC Roots 相关联，导致无法自动 GC 回收。根据引用链信息，可以较准确的定位出泄露代码的位置

  - 比如生命周期远大于使用周期，对象不必要存活，但连接了 GC root：忘记关闭连接、流、线程池 threadLocal 忘了 remove

- 如果不存在内存泄露，或者说内存中的对象确实都有必要存活，那就应当尝试减少程序运行时的内存耗用

  - 检查虚拟机的堆参数（-Xmx 与-Xms），与系统内存对比是否还可以调大

  - 从代码检查是否某些对象生命周期过长（static 转非 static，类成员转方法内...）

### 方法区的内部结构

- ![[Pasted image 20230313224650.png]]

- 方法区存储内容（通过反射获取，这些信息通过 javac 编译成.class 文件，然后由 ClassLoader 放入方法区，并补上 ClassLoader 信息）

  - 方法区存储已被虚拟机加载的类型信息，常量 final，静态变量 static，JIT 编译后的代码缓存

    - 类型信息 Class 包括：类 class，接口 interface，枚举 enum，注解 annotation

      - 对于每个类型，都存储：

        - 这个类型的修饰符，public，abstract，final

        - 这个类的完整有效名称（全名=包名.类名）

        - 这个类型直接父类的完整有效名，对于 interface 或 Object 没有父类

        - 这个类型实现的直接接口（多个）的一个有序列表

    - 域信息 Field（成员变量、属性、字段）

      - JVM 在方法区中保存类型 Class 的所有域的相关信息，以及域的声明顺序

      - 域的相关信息包括：域名称、域类型、域修饰符（public,private,protected,static,final,volatile,transient 的某个子集）

    - 方法信息 Method

      - JVM 在方法区中保存类型 Class 的所有方法（包括构造器）的相关信息，以及方法的声明顺序

      - 1.  方法名称

      - 2.  方法返回类型或 void

      - 3.  按顺序的传入方法形参的数量和类型

      - 4.  方法修饰符

        - public，private，protected，static，final，synchronized，native，abstract 的一个子集

      - 5.  方法的字节码 bytecodes，操作数栈<font color="#ff0000">的大小</font>，局部变量表<font color="#ff0000">的大小</font>

      - 6.  异常表（abstract 和 native 方法除外）

        - 每个异常处理的开始位置，结束位置，代码处理在程序计数器中的偏移地址，被捕获的异常类的常量池索引。

    - non-final 的 static 类变量

      - 静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分

      - 类变量被类的所有实例共享，即使没有类实例也可以访问

      - 以下不会 NullPointerException
      - ![[Pasted image 20230313224715.png]]

    - static final 全局常量

      - 被声明为 final 的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。

      - 对于 static int count = 1; final static int number = 2，使用 javac 编译后.class 如下，可看到 count 还未被加载(准备阶段隐式赋值，初始化阶段显示赋值)，所以没有赋值；number 是全局常量，已经赋值 ConstantValue: int 2
      - ![[Pasted image 20230313224726.png]]

    - 常量池（∈ 静态的字节码.class 文件）

      - 方法区，内部包含了运行时常量池

      - 字节码文件，内部包含了静态的常量池，加载到方法区后，成为运行时常量池

      - 要弄清楚方法区，需要理解清楚.class，因为加载类的信息都在方法区

      - 要弄清楚方法区的运行时常量池，需要理解清楚.class 中的常量池

      - 一个有效的字节码文件中除了包含的上述类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是<font color="#ff0000">常量池表</font>（Constant Pool Table），包括各种<font color="#ff0000">字面量</font>(10、"123")和对<font color="#ff0000">类型、域和方法的符号引用</font>

      - 为什么要用常量池？

        - 一个 java 源文件中的类、接口，编译后产生一个.class 字节码文件。而字节码需要基础数据支持，通常这种数据会很大，以至于不能直接存到字节码里。

          - 以下.java 文件如果真要从无到有，包含全体 String，System 等信息，大小肯定不止 194Byte
          - ![[Pasted image 20230313224734.png]]

        - 换一种方式，把这些经常用到的基础元素 String，System 等存到常量池，这个字节码包含了指向常量池的引用，执行时只需将常量池中的符号引用转为基础元素的直接引用就行了。而符号引用可以复用，大大节省空间。在动态链接会用到运行时常量池。

      - 常量池有什么？

        - 数量值

        - 字符串值

        - 类引用（包括 this）

        - 字段引用

        - 方法引用

      - 常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型

    - 运行时常量池（∈ 动态的方法区，其信息量是常量池的超集）

      - 常量池是.class 文件的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类和接口加载到 JVM 后，创建并存放到方法区的运行时常量池中。

      - JVM 为每个已加载的类型（类、接口、枚举、注解）都维护一个常量池，<font color="#ff0000">池中的数据通过 JVM 指令+索引（#数字）访问</font>

        - 常量池存储元素数量为 N，则索引为从#1 到#N-1

      - 运行时常量池包含多种不同的常量，包括编译期就已经明确的数值字面量（静态解析得到），也包括到运行期动态链接后，才能够获得的方法或者字段引用。此时在运行时常量池中，对应的就不再是常量池中的符号引用了，而是转换为直接地址。

      - <font color="#ff0000">运行时常量池</font>，相对于 class 文件常量池的另一个重要特征是：<font color="#ff0000">具备动态性</font>

        - 例如：String.intern 可以将字符串放入运行时常量池

      - 如果创建运行时常量池所需的内存空间，超过了方法区所能提供的最大值。则抛出 OOM 异常

### 方法区使用举例（P96）

### 💡💡 方法区的演进细节

- 只有 HotSpot 才曾经有过永久代

- Q：说说 HotSpot 中方法区的变化

  - jdk6-，有永久代，静态变量存放在永久代上

    - Sun 收购 JRockit，就想把元空间引入 HotSpot，但工程量太大，因此在 jdk7 过渡
    - ![[Pasted image 20230313224748.png]]

  - jdk7 有永久代，但已经逐步去永久代，字符串常量池，静态变量从方法区移到堆中

    - ![[Pasted image 20230313224755.png]]

  - jdk8+，无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池，静态变量仍在堆

    - ![[Pasted image 20230313224802.png]]

- Q：永久代为什么被元空间替换？

  - 为<font color="#ff0000">永久代设置空间大小很难确定</font>，在某些场景下，如果动态加载类过多，就容易产生 OOM

  - 对永久代进行调优是很困难的

  - 元空间并不在虚拟机中，而是使用本地内存，因此默认情况下，元空间的大小仅受本地内存限制

- Q：StringTable 为什么要从方法区入堆？

  - jdk7 中将 StringTable 放到了堆空间中，因为永久代的回收率很低，在 fullGC 的时候才触发。而 fullGC 是老年代空间不足，永久代不足时才触发

  - 这就导致了 StringTable 回收率不高，而<font color="#ff0000">开发中会创建大量的字符串</font>，回收率低，导致永久代内存不足。放到堆里，能及时回收内存。

- static<font color="#ff0000">变量</font>的存储位置有变化，但其存储<font color="#ff0000">内容一直在堆</font>

  - 如 static int a = 1; "a"有变化，"1"一直在堆

### 方法区的垃圾回收（规范不要求，HotSpot 采用）

- Java 虚拟机规范对方法区的约束非常宽松，不要求虚拟机在方法区实现垃圾收集。事实上，也确实有未实现或未能完整实现方法区类型卸载的收集器，如 JDK11 ZGC

- 方法区的垃圾收集主要回收两部分内容

  - 常量池中废弃的常量

    - 方法区内常量池中主要存放的两大类常量：

      - 字面量

        - 比较接近 Java 语言层次的常量概念，如文本字符串，被声明为 final 的常量值等

      - 符号引用

        - 属于编译原理方面的概念

          - 类和接口的全限定名

          - 字段的方法和描述符

          - 方法的名称和描述符

    - 只要常量池中的常量没有被任何地方引用，就可以被回收，与回收 Java 堆中垃圾对象非常类似

  - 不再使用的类型

    - 需要同时满足三个前提条件

      - 该类及子类所有的实例已经被回收（堆中对象实例会指向方法区中的类模板）

      - 加载该类的类加载器已经被回收

      - 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问改类的方法

    - 满足以上三个条件后，并不是和对象一样立即被回收，仅仅是允许。

    - 在<font color="#ff0000">大量使用反射、动态代理、CGLib</font>等字节码框架，动态生成 JSP、OSGI 这类<font color="#ff0000">频繁自定义类加载器</font>的场景中，通常都需要 Java 虚拟机具备类型回收的能力，以保证不会对方法区造成过大的内存压力

## 对象实例化、内存布局、访问定位（横向串联堆栈方法区）

### 对象的实例化

- 创建对象的 6 方式

  - 1.  new+Xxx 类构造器

    - 最常见的方式

    - 单例模式 Xxx 的 getInstance 静态方法

    - 工厂类 XxxBuilder/XxxFactory 的静态方法

  - 2.  Class.newInstance()

    - JDK9 标记 Deprecated，反射的方式，只能调用默认的空参 public 构造器

  - 3.  Class.Constructor.newInstance()

    - 反射的方式，可以调用空参，带参的构造器，权限没有要求。

  - 4.  使用 clone

    - 不调用任何构造器，当前类需要实现 Cloneable 标识接口，重写 Object 的 clone 方法（不重写只复制引用，是浅拷贝；创建对象并复制是深拷贝）

  - 5.  使用反序列化

    - 从文件、网络等获取一个实现 Serializable 接口对象的二进制流

  - 6.  第三方库 Objenesis

- 创建对象的步骤

  - 1、判断对象对应的类是否已经加载于内存

    - 当虚拟机遇到一条字节码 new 指令时，首先去检查这个指令的参数类，能否在元空间的运行时常量池中，定位到一个类的符号引用(#数字 utf-8 类名)

    - 检查这个符号引用代表的类是否被加载解析初始化过（即类模板是否已经存在于方法区）

      - 如果没有，在双亲委派机制下，使用当前类加载器以 ClassLoader+包名+类名为 key 值查找对应的.class 文件

        - 如果找到，使用 ClassLoader 再次进行类的加载，生成 Class 模板放入方法区

        - 如果没有找到文件，则抛出 ClassNotFoundException 异常

  - 2、为对象分配内存

    - 首先计算对象占用空间的大小（加载时确定），如果实例成员变量是引用变量，仅分配引用变量空间即可，即 4 个字节大小（Double Long 8Byte，其余 4 字节）

    - 接着在堆中划分一块内存给新对象，需要确定堆空间是否规整、无碎片

      - 指针碰撞：假设堆内存是规整的，所有被使用过的内存放在一边，空闲的内存放在另一边，中间放一个指针作为分界点指示器。那么内存分配就是指针指向空闲的方向，挪动一段与对象大小相等的距离

        - 仅针对能进行碎片压缩的 GC，包括 Serial、ParNew 压缩算法

      - 空闲列表：如果堆内存不规整，虚拟机就必须维护一个列表，记录哪些内存可用，哪些不可用。分配的时候在列表中找一个足够大的空间分配，然后更新列表

        - 当使用 CMS 基于标记清除（Sweep）算法收集器时，只能采用空闲列表来分配内存

        - CMS 为了能在多数情况下分配内存更快，设计了一个 Linear Allocatioin Buffer 的分配缓冲区，通过空闲列表拿到一大块分配缓冲区后，在它内部仍可使用指针碰撞方式分配

  - 3、处理并发安全问题

    - 对象创建是非常频繁的行为，还需要考虑并发情况下，仅仅修改一个指针所指向的位置也是不安全的，例如正在给对象 A 分配内存，指针还未修改，对象 B 又使用原来的指针分配内存。解决问题有两种可选方案：

      - a、对分配内存空间的动作进行同步处理。实际上虚拟机采取乐观自旋锁 CAS+失败重试保证更新操作的原子性。

      - b、把内存分配的动作按照线程划分到不同的空间中进行，每个线程在 Java 堆中，预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB，默认占 Eden1%），只有 TLAB 用完了，分配新的缓存区时才需要 a 中的同步锁定。

      - 虚拟机是否使用 TLAB，可以通过-XX: +/-UseTLAB 参数来设定。

  - 4、默认初始化分配到的空间

    - 内存分配完成后，虚拟机将分配到的内存空间（不包括对象头）都初始化为零值。如果使用了 TLAB，这个工作可以提前到 TLAB 分配时进行。<br>

    - 这步操作保证对象的实例字段在 Java 代码中，可以不赋初始值就直接使用，程序可以访问到字段对应数据类型所对应的默认零值。

  - 5、设置对象的对象头

    - 接下来 Java 虚拟机还要对对象进行必要的设置，例如对象是哪个类的实例（即对象会指向方法区类模板）、对象的哈希码（实际上 HashCode 会延后真正调用 Object::hashCode()方法时才计算）、对象的 GC 分代年龄等信息。这些信息存放到对象的对象头（Object Header）<br>

  - 6、执行 init 方法进行显式初始化

    - 上面工作完成后，从虚拟机角度来说，一个新的对象已经产生了，但是从 Java 程序的视角来说，对象创建才刚刚开始，对象的构造方法（Class 文件中 init()方法）还未执行，所有字段都是默认的零值。new 指令之后接着执行 init 方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全构造出来<br>

### 对象的内存布局

- 对象头

  - 包含两部分

    - 运行时元数据：这部分数据的长度在 32 位和 64 位的虚拟机（未开启指针压缩中）分别是 32bit 和 64bit

      - 哈希值（对象的堆中首地址）

      - GC 分代年龄 age

      - 锁状态标志

      - 线程持有的锁

      - 偏向线程 ID

      - 偏向时间戳

      - 对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，根据对象状态的不同，Markword 可以复用自己的空间。

    - 类型指针 clazz.getClass()

      - 即对象指向方法区它的类模板的指针，Java 虚拟机通过这个指针来确认该对象属于哪个类的实例

    - 说明：如果是数组对象，还需要记录数组的长度

  - 对象头信息是可变的，比如锁升级，fromTo 区 age++

- 实例数据

  - 对象的实例数据部分，是对象的真正存储的有效信息，即我们在程序代码中定义的各种类型的字段内容，无论是父类继承下来，还是子类中定义的字段都要记录下来。

  - 1、这部分的存储顺序会受到虚拟机分配策略参数-XX:FieldsAllocationStyle 和字段在 Java 源码中定义顺序的影响。<br>2、HotSpot 虚拟机默认的分配顺序为 longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），即相同宽度的字段总被分配到一起存放<br>3、在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。<br>4、如果 HotSpot 虚拟机的+XX：CompactFields 参数值为 true（默认也是 true），那么子类中较窄的变量也允许插入父类变量的空隙之间，以节省一点点空间。<br>

- 对齐填充

  - 并不是必然存在，没有特别的意义，它仅仅起着占位符的作用。

    - 因为 HotSpot 虚拟机自动内存管理系统，要对对象的起始地址必须是 8 字节的整数倍，换句话就是任何对象的大小都必须是 8 字节的整数倍。

    - 对象头已经精心设计为 8 字节的整数倍，1 倍或者 2 倍。

    - 对象实例数据部分如果没有对齐的话，就需要通过对齐填充来补全。

  - 使用@Contentded 注解主动申请填充，让每个类变量处于不同缓存行，防止伪共享（指所有变量位于同一缓存行，一个变量修改，整行更新，影响效率）

- e.g. record Class Customer(int id=1001; String name; Account acct);
- ![[Pasted image 20230313224858.png]]

### 对象的访问定位

- 使用句柄

  - 使用句柄，Java 堆中将划出一块内存作为句柄池，reference 中存储的就是对象的句柄地址，句柄包含对象实例数据与类型数据各自的具体信息。

    - ![[Pasted image 20230313224907.png]]

- 直接指针(HotSpot 采用)

  - 使用指针，reference 中存储的直接就是对象地址，如果访问对象本身，不需要多一次的间接访问的开销。

    - ![[Pasted image 20230313224921.png]]

- 两种方式各有优势：

  - 使用句柄最大好处是 reference 中存放的是稳定句柄池地址，在对象被移动（GC 时会产生，对象在各种区的转移）时只改变句柄池中实例数据指针，局部变量表中 reference 本身仍指向句柄池不用改变。

  - 使用指针最大好处就是速度快，节省了一次指针定位的时间开销，由于对象访问在 Java 中非常频繁，所以积少成多也是一项可观的执行成本。

  - HotSpot 主要是用指针，进行对象访问（例外情况，如果使用 Shenandoah GC 的话，也会有一次额外的转发）。

## 直接内存

- 不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域

- 直接内存是在 java 堆外的，直接向系统申请的内存区间

- 来源于 NIO，通过存在堆中的 DirectByteBuffer 操作 Native 内存

- 通常，访问直接内存的速度会优于 Java 堆，即读写性能高

  - 因此出于性能考虑，<font color="#ff0000">读写频繁的场合可能会考虑使用直接内存</font>

  - Java 的<font color="#ff0000">NIO 库允许 Java 程序使用直接内存</font>，用于数据缓冲区

- 也可能导致 OOM 异常

  - 直接内存在堆外，所以大小不受限于-Xmx 指定的最大堆大小

  - 但是系统内存是有限的，Java 堆和直接内存的总和依然受限于操作系统能给出的最大内存

  - 如果 OOM，且 dump 文件本身很小，表明记录的 jvm 内存信息很少，考虑是本地内存 OOM，NIO/Netty 出问题

- 缺点

  - 分配回收成本较高

  - 不受 JVM 内存回收管理，dump 无记录

- 直接内存大小可以通过 MaxDirectMemorySize 设置

- 如果不指定，默认与堆的最大值-Xmx 参数值一致

## 执行引擎

### 执行引擎概述

- 虚拟机的执行引擎由软件自行实现，物理机的执行引擎是操作系统层面上

- 能够翻译不被硬件直接支持的 jvm 字节码指令(invokeXXX, dup)、符号(#num)，使之成为汇编或机器指令

- 执行引擎的工作过程

  - 1、执行引擎执行的字节码指令，依赖于 PC 寄存器存储的内容。

  - 2、每当执行完一项指令操作后，PC 寄存器就会更新下一条需要被执行的指令地址

  - 3、方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用，准确定位到存储在 Java 堆区中的对象实例信息，以及通过对象头中的元数据指针定位到方法区中目标对象的类型模板信息

### Java 代码编译和执行过程

- 大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图中的各个步骤
- ![[Pasted image 20230313225120.png]]

- 为什么说 Java 是半编译半解释型语言

  - JVM 在执行 Java 代码的时候，通常会将解释执行与 JIT 编译执行二者结合起来进行

  - ![[Pasted image 20230313225126.png]]

### 机器码，指令，汇编语言（了解）

- 机器码

  - 各种采用二进制编码方式表示的指令，叫做机器指令码。机器语言。机器指令与 CPU 紧密相关，不同种类的 CPU 所对应的机器指令也就不同

- 指令

  - 由于机器码由 01 组成，可读性太差。于是人们发明了指令

  - 指令就是把机器码特定的 0 和 1 序列，简化成对应的指令，一般为英文编写如 mov，inc 等，可读性稍好

  - 由于不同的硬件平台，执行同一个操作，对应的机器码可能不同。所以不同的硬件平台的同一种指令，对应的机器码也可能不同

- 指令集

  - 不同硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集

  - x86 指令集，对应的 x86 架构的平台

  - ARM 指令集，对应的是 ARM 架构的平台

- 汇编

  - 由于指令的可读性也差，于是又有了汇编语言

  - 汇编语言用助记符代替机器指令的操作码，用地址符号或标号，代替指令或操作数的地址。

  - 汇编语言要翻译成对应机器指令码，计算机才能识别和执行

  - ![[Pasted image 20230313225135.png]]

### 解释器

- 当 Java 虚拟机启动时，会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容翻译为对应平台的本地机器指令执行

- 解析器真正意义上所承担的角色就是一个运行时翻译者，将字节码文件中的内容翻译为对应的平台的本地机器指令执行

- 当一条字节码指令被解释执行完成后，接着在根据 PC 寄存器中的记录下一条需要被执行的字节码执行解释执行

- 古老的字节码解释器

- 现在普遍使用的模板解释器

  - 模板解释器将每一条字节码和一个模板函数相关联，模板函数直接产生这条字节码执行时的机器码，提高解释器的性能

- HotSpot 中

  - Interpreter 模块

    - 实现了解释器的核心功能

  - Code 模块

    - 用于管理 HotSpot 在运行时生成的本地机器指令

### JIT 编译器

- 就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言

- JVM 平台支持一种叫做即时编译的技术，目的是避免解释执行，而是将整个函数体编译成机器码，每次函数执行时，只执行编译后的机器码即可。使执行效率大幅提升

### 为什么两条腿走路？

- 首先程序启动后，解释器可以马上发挥作用，省去编译时间，立即执行

- JIT 编译器要想发挥作用，把热点字节码编译成本地代码，需要一定的探测时间（冷启动）。但编译为本地代码后执行效率更高

- 对于服务端应用，启动时间并非关注重点；但是对于看重启动时间的应用场景，就需要找到一个平衡点。

- 当 Java 虚拟机启动时，解释器可以首先发挥作用，而不是等待 JIT 编译器全部编译完成后再执行，这样可以省去很多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率

  - ![[Pasted image 20230313225151.png]]

### 概念解释

- 前端编译器

  - 把.java 文件转换为.class 文件的过程

    - sun 的 Javac

- 后端运行期编译器

  - 把字节码转为机器码的过程

    - JIT 编译器：hotSpot 的 C1,C2 编译器

- 静态提前编译器

  - Ahead of Time Compliler AOT，直接把.java 文件编译器本地机器代码的过程

    - GNU Compiler for the Java（GCJ）

### 什么时候选择 JIT，JIT 原理

- 热点代码及探测方式

  - 需要根据代码被调用执行的频率而定，需要被编译为本地代码的字节码，也称之为热点代码。

  - JIT 编译器会在运行时针对频繁调用的热点代码做出深度优化，将其直接编译为对应平台的本地机器指令。以此提升 Java 程序的执行性能

  - 一个被多次调用的方法，或者一个方法体内部循环次数较多的循环体，都可以被称之为热点代码

  - 因此热点代码可以通过 JIT 编译器编译为本地机器指令，由于这种编译方法发生在方法的执行过程中，因此也被称之为栈上替换，OSR On Statck Replacement

  - 一个方法调用都少次才能达到标准？这个依靠热点探测功能

    - hotspot 采用的基于计数器的热点探测

      - 回边计数器

        - 统计循环体执行的循环次数

          - ![[Pasted image 20230313225201.png]]

      - 方法调用计数器

        - 统计方法调用次数

          - 默认阈值，Client 模式下是 1500 次，Server 模式下是 10000 次

          - -XX:CompileThreshold

        - 热度衰减

          - 当超过一定的时间限度，如果方法调用次数仍然不足以提交即时编译器编译，那么这个方法的调用计数器就会被减少一半。

          - -XX:UseCounterHalfLifeTime 参数设置半衰周期的时间，单位是秒

          - -XX:-+UseCounterDecay 关闭开启热度衰减

        - 当一个方法被调用时，如果不存在已被编译过的版本，则将此方法的调用计数器+1，然后判断方法调用计数器与回边计数器之和，是否超过方法调用计数器的阈值。如果已经超过，会向即时编译器提交一个该方法的代码编译请求。

          - ![[Pasted image 20230313225209.png]]

### hotspot 可以设置程序执行的方式

- -Xint：完全采用解释器模式执行

- -Xcomp 完全采用即时编译器模式执行，如果即时编译器出现问题，解释器会介入执行

- -Xmixed 采用解释器+即时编译器的混合模式共同执行

### hotspot 中 JIT 编译器分类

- -server：指定虚拟机在 server 模式下（64 位默认 server 模式），并使用 C2 编译器

  - C2 进行耗时较长的优化，以及<font color="#ff0000">激进优化（如果失效，换上解释器）</font>，单优化后的代码执行效率更高

    - 逃逸分析是优化的基础，<font color="#ff0000">基于逃逸分析</font>在 C2 上有几种优化

      - 标量替换

        - 用标量值代替聚合对象的属性值

      - 栈上分配

        - 对于未逃逸的对象分配在栈而不是堆

      - 同步消除

        - 清除同步操作，通常指 synchronized

- -client：指定虚拟机在 Client 模式下，并使用 C1 编译器

  - C1 编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度

    - 方法内联

      - 将引用的函数代码编译到引用点处，减少栈帧的生成，减少参数传递以及跳转过程

    - 去虚拟化

      - 对唯一的实现类进行内联

    - 冗余消除

      - 在运行期把一些不会执行的代码折叠掉

- <font color="#0000ff">Graal</font>

### Graal AOT

- jdk10 起，hotspot 又引入了全新的即时编译器：Graal，与 C1、C2 并列

- JDK9 引入了 AOT 编译器，编译前判断热点，生成指令，更快，但会破坏多平台性，仅 linux64 支持

## 💡💡StringTable

### String 的基本特性

- 字符串，用" "引起来表示

- 声明为 final，不可被继承

- 实现了 Serializable 接口，表示支持序列化，可以跨进程传输

- 实现了 Comparable\<String\>接口，表示可以比较大小

- jdk8 及以前，内部定义了 final char[] value 用于存储字符串数据

- JDK9 时改为<font color="#ff0000">byte[]</font>

  - String 是堆空间的主要部分，大部分是 latin-1 字符，一个 Byte 就够了。而一个 char 占 2 Byte，这样会有一半空间浪费

  - 中文等 UTF-16 的用两个字节存储的，改为 1 个 Byte+标识。

  - StringBuffer，StringBuilder 同样做了修改

- String 代表<font color="#ff0000">不可变的字符序列，</font>需要重新指定内存区域赋值，不能使用原有的 value[]进行赋值

  - 当字符串重新赋值

  - 当对现有的字符串进行连接操作时

  - 当调用 String 的 replace 方法修改指定字符或字符串时

- 通过字面量的方式，区别于 new 给一个字符串赋值，此时的字符串值存在于字符串常量池中

- 字符串常量池中不会存储相同的字符串的

  - String 的 StringTable 是一个<font color="#ff0000">固定大小的 HashTable</font>，默认大小长度是 1009，不会扩容。如果放进 String Pool 的 String 非常多，就会造成 Hash 冲突严重，从而导致链表会很长，而链表长了，直接影响就是调用 String.intern 时性能会大幅下降

  - -XX:StringTableSize 可设置 StringTable 的大小

  - JDK6 固定 1009，jdk7 中 StringTable 默认的长度是 60013，jdk8+1009 是可设置的最小值

### String 的内存分配

- Java 语言中有 8 种基本数据类型，和一种比较特殊的类型 String，这些类型为了使他们再运行过程中速度更快，更节省内存，都提供了一种常量池的概念（等价于 cache）

  - String 的常量池比较特殊，主要使用方法有两种

    - 直接使用双引号，声明出来的 String 对象会直接隐式地存储在常量池中

    - 如果不是双引号声明的 String 对象，可以使用 String 提供的 intern()方法显式放入常量池

- jdk6 及之前，字符串常量池存在永久代

- jdk7 中，字符串常量池调整到 Java 堆中

  - 调优时仅需调整堆大小就可以

- Jdk8 中，字符串常量在堆

- 为什么要调整？

  - 永久代默认情况下比较小，大量字符串容易导致 OOM。

  - 永久代垃圾回收频率低，在 fullGC 的时候才触发，而 fullGC 是老年代空间不足，永久代不足时才触发，放到堆里，能及时回收内存。

### String 的基本操作

- Java 语言规范要求完全相同的字符串字面量，应该包含同样的 Unicode 字符序列，包含同一份码点序列的常量，并且必须<font color="#ff0000">指向同一个 String 类实例</font>

### 字符串拼接操作

- 字面量与字面量的拼接结果在常量池<font color="#ff0000"></font>

  - 原理是<font color="#ff0000">编译期优化</font>
  - ![[Pasted image 20230313225254.png]]

- 常量池中不存在相同内容的常量

- 只要其中有一个是变量，拼接结果就在堆中（常量池以外的堆），变量的拼接原理是 new StringBuilder.toString

  - ![[Pasted image 20230313225301.png]]

  - ![[Pasted image 20230313225307.png]]

- 如果拼接的结果调用 intern 方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址

- 字符串拼接操作不一定使用的是 StringBuilder，如果拼接符号左右两边都是<font color="#ff0000">字面量</font>，或<font color="#ff0000">final 的字符串常量或常量引用（指 final String s = "123"，而非 final String s = new String("123")，后者仍不会优化）</font>，则仍然使用编译期优化

  - 针对 final 修饰类，方法，基本数据类型，引用数据类型变量的结构时，<font color="#ff0000">能使用 final 尽量使用上</font>
  - ![[Pasted image 20230313225319.png]]

- 对比用+号拼接字符串和 StringBuilder.append 操作对比

  - 拼接 10 万次，+号 4000，append 用了 7 毫秒，原因是+号每次循环创建一个 StringBuilder，还要通过 toString 创建一个 String 对象

  - 内存中由于创建了较多的对象，内存占用更大，如果需要 GC 需要花费额外的时间

  - 改进空间：<font color="#ff0000">StringBuilder</font>默认是 16 长度的 char 型数组，不够的时候会扩容，可以<font color="#ff0000">一次建一个比较大长度的数组</font>。

### 💡intern()方法

- 在字符串常量池中，通过 equals 判断是否相同，如果不同则在常量池中生成

- 确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度，注意，这个值会被存放在字符串内部池。（String intern pool）

- 面试题

  - ![[Pasted image 20230313225325.png]]

    - jdk6 执行结果

      - false false

      - 调用 s.intern 方法之前，字符串常量池已经有 1

    - jdk7/8

      - false true

        - s3 的变量地址为：new String （“11”）。执行完字符串常量池中不存在 11，s3.intern 会在字符串常量池<font color="#ff0000">“生成”</font>11，s4 变量记录的地址是常量池中的。

        - jdk6"生成"：因为常量池在永久代，永久代在堆外使用系统内存，不用担心重复问题，所以直接在堆外-\>永久代-\>运行时常量池-\>字符串常量池创建一份”11“

        - JDK7”生成“：因为常量池入堆，如果也在常量池创建"11"，堆中池外同时存在 new String("11")，重复。所以改为在堆中-\>字符串常量池创建一个指向堆中-\>池外 newString（“11”）的地址，节省堆空间。
        - ![[Pasted image 20230313225340.png]]

  - 变形

    - ![[Pasted image 20230313225348.png]]

  - newString("ab")会创建几个对象？

    - 2 个对象，查看字节码验证。一个是常量池 ab，一个是 new 出来在堆空间。（前提是常量池没有 ab）

  - new String("a") + new String("b")会创建几个对象?

    - 对象 1，存在无优化的拼接操作，堆中 new StringBuilder

    - 对象 2，常量池"a"

    - 对象 3，堆中 new String("a")，然后 append 进 StringBuilder

    - 对象 4，常量池"b"

    - 对象 5，堆中 new String("b")，然后 append 进 StringBuilder

    - 对象 6，StringBuilder，toString 方法会利用堆中 value[]，new String(value[]...)返回堆中"ab"

    - 此时字符串常量池中没有"ab"

- 总结

  - jdk1.6 中，将这个字符串对象放入串池

    - 如果串池中有，则并不会放入，返回已有串池中的对象的地址，

    - 如果没有，会把对象复制一份，放入串池，并返回串池中的对象地址

  - jdk1.7 起，将这个字符串对象尝试放入串池

    - 如果串池中有，则并不会放入，返回已有的串池中的对象的地址

    - 如果没有，则会把对象的引用地址复制一份，放入串池，并返回串池中的引用地址

- 练习

  - ![[Pasted image 20230313225357.png]]

- intern（）的效率测试

  - 大的网站平台，需要内存中存储大量的字符串，比如社交网站，很多人存储：北京市，海淀区等信息，这时候如果字符串调用 intern 方法，则会明显降低内存的大小，因为.intern 前 new 的内容会被 GC

### Stringtable 的垃圾回收

- -XX:+PrintStringTableStatistics

### G1 中 String 去重操作

- 背景：对许多 Java 应用，做的测试结果如下

  - 堆存活数据集合里面 String 对象占了 25%

  - 堆存活数据集合里面重复的 String 对象有 13.5%

  - String 对象的平均长度是 45

- 许多大规模的 Java 应用的瓶颈在于内存。Java 堆中存活的数据集合差不多 25%是 String 对象，这里差不多一半的 String 对象是重复的， 重复是指 equals 方法=true,堆上重复的 String 对象必然是一种内存的浪费。G1 垃圾收集器中实现自动持续对重复的 String 对象进行去重，去的是池外 byte[]重复，字符串常量池中没重复。

- 原理：使用队列存储潜在重复对象的引用，开一个线程处理队列中的对象；用 hashtable 存不重复的 byte[]

## 垃圾回收概述

### 什么是垃圾

- 垃圾是指运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。

### 为什么需要 GC

- 如果不及时 GC，垃圾对象占用空间直至进程结束，期间如果可用空间不足，会导致内存溢出 OOM

- GC 可以整理碎片化的已用空间，使可用空间连续，方便分配大对象

### 早期 GC

- 手动 GC，free()，delete()，缺点：如果忘记 GC，会导致内存泄漏（野指针）

### java 的 GC

- 重点收集堆，fullGC 也包括方法区，次数：年轻代\>老年代\>方法区
- ![[Pasted image 20230313225421.png]]

## 💡💡 垃圾回收相关算法

### 标记阶段：引用计数算法 reference counting

- 对每个对象保存一个整型的引用计数器 rc 属性，用于记录被对象引用的情况

- 被对象引用了就+1，引用失效就-1,0 表示不可能再被使用，可进行回收

- 优点：实现简单，垃圾便于辨识; 相比于可达性分析算法, 判断效率高，回收没有延迟性

- 缺点

  - 需要单独的字段存储计数器，增加了存储空间的开销

  - 每次赋值需要更新计数器，伴随加减法操作，增加了 CPU 时间开销

  - <font color="#ff0000">无法处理循环引用</font>的情况，致命缺陷，导致 JAVA 的垃圾回收器中<font color="#ff0000">没有使用这类算法</font>

    - ![[Pasted image 20230313225440.png]]

- 小结

  - 引用计数算法，是很多语言和框架的资源回收选择，例如 python，它更是同时支持引用计数和垃圾回收机制

    - Python 如何解决循环引用

      - 手动解除引用关系

      - 使用<font color="#ff0000">弱引用</font>，weakref，python 提供的标准库，旨在解决循环引用

    - Spring 的 IOC 使用<a class="link" target="_bank" href="https://blog.csdn.net/mf97532/article/details/118110506">三级缓存机制</a>解决循环依赖

### 标记阶段：可达性分析算法

- 基本思路

  - 以<font color="#ff0000">根对象（GCRoots）</font>为起始点，按照从上到下的方式搜索被根对象集合所连接的目标对象是否可达

  - 使用可达性分析算法后，内存中存活的对象都被根对象集合直接或间接连接着，搜索所走过的路径称为<font color="#ff0000">引用链</font>

  - 如果目标对象没有任何引用链相连，则是不可达的，意味着该对象已经死亡，可以标记为垃圾对象

  - 解决了循环引用问题

- 💡GC Roots 包括

  - 判断规则: 如果一个指针，它指向<font color="#ff0000">堆内存(仅指新生代+老年代, 不包括方法区)</font>里面的对象，但是自己又不存放在堆内存里面，那么它就是一个 Root

  - 正常情况下，即使只有空 main 方法，也会有 1700+GC Roots

  - VMS 局部变量表中引用的对象

    - 比如各个线程被调用的方法中使用到的参数、局部变量

  - NMS 内本地方法引用的对象

  - 方法区中静态属性引用的对象

    - 比如：java 类的引用类型静态变量

  - 方法区中常量引用的对象

    - 比如字符串常量池里的引用(比如 intern 方法指回堆中)

  - 所有被同步锁 synchronized 持有的对象(同步监视器不能被回收, 否则加锁失效)

  - Java 虚拟机内部的引用

    - 基本数据类型对应的 Class 对象，一些常驻的异常对象，如 NullPointerException，OOM，系统类加载器

  - 反映 java 虚拟机内部情况的 JMXBean，JVMTI 中注册的回调，本地代码缓存等

  - 除了上述固定的 GC Roots 集合之外，根据用户选择的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时性的加入，共同构成完整 GCRoots 集合，比如<font color="#ff0000">分代收集和局部回收时的跨代引用</font>

    - 如果只针对 Java 堆中某一块内存区域(比如只对新生代)进行垃圾回收，因为这个区域的对象可能被其他分代区域对象所引用，所以需要一并将关联的区域对象加入 GC Roots 集合中去考虑，才能保证可达性分析的准确性。

  - 如果需要使用可达性分析算法来判断内存是否可回收，那么分析工作<font color="#ff0000">必须在一个能保障一致性的快照中进行</font>。这点不满足的话，分析结果的准确性就无法保证(类比数据库的幻读)。

  - 这也是 GC 进行时必须 STW 的一个重要原因，即使是号称几乎不会发生停顿的 CMS 收集器中，枚举根节点也是必须要停顿的。

### 临终阶段：对象的 finalization 机制, 类似析构函数

- Java 语言提供了对象终止 finaliztion 机制, 允许开发人员提供对象被销毁之前的自定义处理逻辑, 比如关闭连接, 释放资源等

- 当垃圾回收器发现没有引用指向一个对象，即垃圾回收此对象之前，总会先调用这个对象的 finalize（）方法

- finalize（）方法允许在子类中被重写，用于在对象被回收时进行资源释放，通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件，套接字和数据库链接等

- 定义虚拟机的对象可能的三种状态

  - 可触及的

    - 从根节点开始，可以到达这个对象, 不是垃圾, 不能回收

  - 可复活的

    - 对象的所有引用都被释放了，但是对象有可能在 finalize（）中复活, 是垃圾, 不能回收

  - 不可触及的

    - 对象的 finalize（）被调用，并且没有复活，那么就会进入不可触及状态, 是垃圾, 应该回收

    - 不可触及的对象不可能被复活，因为<font color="#ff0000">finalize（）只会被调用一次</font>

- 具体过程, 注意是垃圾 ≠ 可回收

  - 判断一个对象 A 是否可以被回收，至多需要经历<font color="#ff0000">两次标记</font>过程

    - 1、如果对象到 GCRoots 没有引用链，则进行<font color="#ff0000">第一次标记</font>, 是垃圾, 但不确定能否回收

    - 2、因为 finalize 方法可能复活垃圾, 所以进行筛选，判断此对象是否有必要执行 finalize（）方法

      - 如果对象 A 没有重写 finalize 方法，或者 finalize 方法已经被虚拟机调用过，则虚拟机视为没有必要执行，对象 A 被判定为不可触及的, 可回收

      - 如果对象 A 重写 finalize（）方法，且还未执行过，那么 A 会被插入到 F-queue 队列中，有一个虚拟机自动创建的，低优先级的 Finalizer 线程触发其 finalize（）方法执行

      - finalize 方法是对象逃脱死亡的最后机会，稍后 GC 会对<font color="#ff0000">F-queue 队列中的对象进行第二次标记</font>，如果 A 在 finalize 方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，A 会被移除即将回收集合。

      - 之后，假如对象 A 再次变成垃圾，finalize 方法不会再被调用，对象直接变为不可触及状态, 可回收

### 清除阶段：标记-清除算法

- 标记可达对象

  - 从 GC Root 开始遍历，标记所有经过可达性分析和临终阶段, 确定可以回收的对象，一般是在对象 Header 中记录为可达对象

- 逻辑清除

  - 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其加入空闲列表

- 缺点

  - 效率不算高(递归可达性标记+全表线性遍历=2 \* O(n))

  - 在 GC 的时候，需要 STW，导致用户体验差。

  - 这种方式清理出来的空闲内存不连续，产生内存碎片，需要维护一个空闲列表

- 何为清除？

  - 所谓的清除<font color="#ff0000">并不是真的置空</font>，而是把需要清除的对象地址保存在空闲的地址列表里，下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够就存放。

### 清除阶段：复制算法

- 将活着的内存空间分为两块，每次使用其中一块。在垃圾回收时，将正在使用的内存中的存活的对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有的对象，交换两个内存的角色，最后完成垃圾回收

  - 类比数组原地筛选: int c = 0; for(...) arr[c++] = ...;
  - ![[Pasted image 20230313225518.png]]

- 优点

  - 没有标记和清除的过程，实现简单高效

  - 复制过去以后的保证空间的连续性，不会出现碎片的问题

- 缺点

  - 需要两倍的内存空间, 空间换时间

  - 对于 G1 这种拆分为大量 region 的 GC，如果复制而不是移动，意味着 GC 需要维护 region 之间的引用关系，和 VMS 到堆中的引用关系, 不管是内存占用或者时间开销也不小。

  - 如果堆中大部分是可达对象(比如老年代)，需要复制的存活对象数量会很多, 相应的引用维护也很多, 但实际上没有回收多少垃圾

- 由于新生代 80%的对象朝生即死, 即大部分都不是可达对象, 所以适合回收新生代, 在 Eden 区,幸存者 0, 1 区之间实现了此方法

  - ![[Pasted image 20230313225526.png]]

### 清除阶段：标记-压缩(整理)算法

- 第一个阶段和标记-清除算法一样，从根节点开始标记所有可达对象

- 第二阶段将所有的<font color="#ff0000">存活对象压缩在内存的一端，按照顺序排放</font>

- 之后清理边界外所有的空间

- 最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理。

- 与标记-清除算法本质区别，标记-清除算法是非移动式的算法，标记-压缩是移动式的

- 优点

  - 消除了标记-清除算法内存区域分散的缺点, 即再分配对象内存时无需维护空闲列表, 可用指针碰撞

  - 消除了复制算法中，内存减半代价

- 缺点

  - 从效率上来讲，标记-整理算法要低于复制算法

  - 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址

  - 移动的过程中需要 STW(在 ZGC 中通过读屏障\染色指针\内存多重映射实现可并发, 无需 STW)

### 小结

- ![[Pasted image 20230313225549.png]]

### 分代收集算法

- 不同生命周期的对象可以采取不同的算法，以便提高回收效率

  - 年轻代

    - 生命周期短，存活率低，回收频繁-\>复制算法

  - 老年代

    - 区域较大，生命周期长，存活率高，回收不频繁-\>标记清除(CMS) /标记压缩(Serial Old)

### Boost: 增量收集算法、分区算法

- 一次回收所有垃圾, STW 时间过长, 影响用户体验

- 增量收集算法

  - 每次垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程，依次反复，直到垃圾收集完成

  - 通过对线程间冲突的妥善管理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作

  - 缺点

    - 线程和上下文切换导致系统吞吐量的下降

- 分区算法

  - 为了控制 GC 产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理的回收若干个小区间，而不是整个堆空间，从而减少一次 GC 所产生的时间

  - 分代算法是将对象按照生命周期长短划分为两个部分，分区算法是将整个堆划分为连续的不同的小区间

  - 每一个小区间都独立使用，独立回收，这种算法的好处是可以控制一次回收多少个小区间

## 垃圾回收相关概念

### System.gc()的理解

- System.gc 或 Runtime.getRuntime().gc()的调用，会显示触发 FullGC，同时会对老年代和新生代进行回收，尝试释放垃圾对象占用的内存

- System.gc 调用无法保证垃圾收集器一定调用，只是提醒，因此也不一定调用 finalize

  - System.runFinalization 强制调用 finalize

- 一些特殊情况下，比如编写性能基准测试，我们可以在运行之前调用 System.gc，相当于复位

### 内存溢出与内存泄露

- OOM

  - 内存空间不足，并且即使 GC 了也不足

  - java 虚拟机的堆内存设置不够

  - 代码创建大量大对象，并且长时间不能被垃圾收集器收集（泄露）

  - 一般情况下，OOM 之前一定尝试过 GC，除非超大对象大小已经超过全部分配内存的上限（JVM 预判 GC 也没用）

- 内存泄露

  - 只有对象不再被程序用到了，但是 GC 又不能回收他们的情况，才叫内存泄露

  - 实际情况有一些疏忽导致对象的生命周期变的很长甚至 OOM，宽泛意义上的内存泄露

  - 举例

    - 单例的生命周期和程序是一样长，如果单例程序中，持有对外部对象的引用的话，那么这个外部对象是不能被回收的，导致内存泄露

    - 一些提供 close 的资源未关闭导致内存泄露，如数据库链接 Conneection，网络链接 Socket，和 IO

    - jdk7-，hashmap 底层使用数组+链表，且链表使用头插法创建，在<a class="link" target="_bank" href="https://www.csdn.net/tags/MtTaMgzsMjY3NzM2LWJsb2cO0O0O.html">高并发场景下会出现循环链表</a>，无法被回收；jdk8+使用红黑树+尾插法解决

### STW，确保 GC 时的一致性

### 安全点与安全区域

- 安全点

  - 程序执行并非在所有地方都能停顿下来开始 GC，只有<font color="#ff0000">特定的位置才能停顿下来开始 GC</font>，这些位置称为安全点

  - 如果太少，导致 GC 等待时间长，如果太多导致运行时性能问题。

  - 选择标准：大部分指令执行都比较短，通常会根据是否具有让程序长时间执行的特征为标准选择。一些执行时间较长的指令作为安全点，比如方法调用，循环跳转和异常跳转等

  - 抢先式中断

    - 中断所有线程，如果还有线程不在安全点，就恢复线程，让线程跑到安全点

    - 没有虚拟机采用

  - 主动式中断

    - 设置一个中断标志，各个线程运行到安全点的时候，主动轮询这个标志，如果标志为真，则将自己进行中断挂起

- 安全区域

  - 如果线程处于 sleep 或者 blocked 状态，这时候线程无法响应 jvm 中断请求，走到安全点去中断挂起。对于这种情况，就需要安全区域来解决

  - 安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中任何位置开始 GC 都是安全的。

  - 当线程运行到安全区域代码时，首先标志已经进入了安全区域，如果 GC，JVM 会忽略标识为安全区域状态的线程

  - 当线程即将离开安全区域时，会检查 JVM 是否已经完成 GC，如果完成了，则继续运行。否则线程必须等待直到收到可以安全离开安全区域的信号为止

### 强引用

- ![[Pasted image 20230313225622.png]]

- 最传统的引用定义，程序代码中普遍存在的引用赋值，类似 Object obj = new Object 这种引用关系

- 无论任何情况下，强引用存在，垃圾收集器永远不会回收掉被引用的对象

- 强引用是造成 java 内存泄露的主要原因之一

- 强引用可以直接访问目标对象

### 软引用

- 系统将要发生内存溢出（老年代将满）之前，会将这些对象列入回收范围之中进行<font color="#ff0000">第二次回收</font>，如果二次回收后还没有足够内存，才会抛 OOM

- 软引用通常用来实现内存敏感的缓存，高速缓存就有用到软引用

- MyBatis 内部类使用了软引用

- 垃圾回收器在某个时间决定回收软可达的对象的时候，会清理软引用，并可选的把引用存放到一个引用队列

### 弱引用(见光死)

- 只被弱引用关联的对象只能生存到下一次垃圾收集器之前，当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象

- 用于缓存

- Java 中的 WeakHashMap 的 Entry 继承了 WeakReference，键 key 是弱引用，会在 GC 时回收

### 虚引用

- 一个对象是否有虚引用存在，完全不会对其生存时间构成影响。

- 唯一目的就是在这个对象被收集器回收时收到一个系统通知，用于追踪回收过程。

- 不能单独使用，需要 RefQueue，也无法通过虚引用获取被引用的对象。

### 终结器引用

- 用以实现对象的 finalize 方法，所以被称为终结器引用

- 无需手动编码，其内部配合引用队列使用

- GC 时，终结器引用入队，由 finalize 线程通过终结器引用找到被引用对象并调用 他的 finalize 方法，第二次 GC 时才能回收被引用对象

## 💡💡💡 垃圾回收器

### 垃圾回收器分类

- 按垃圾回收线程数

  - 串行垃圾回收器

    - ![[Pasted image 20230313225633.png]]

    - 串行回收指同一个时间段内，只允许一个 CPU 用于执行垃圾回收操作，此时用户线程被暂停，直到垃圾收集工作结束

      - 在单 CPU 处理器或者较小应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以串行回收默认被应用在客户端的 client 模式下的 JVM 中

      - 在并发能力比较强的 CPU 上，并行回收器产生的停顿时间要短于串行回收器

  - 并行垃圾回收器

    - 和串行相反，并行收集可以运用在多个 CPU 同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了 STW 机制

- 按照工作模式分

  - 并发式

    - 垃圾回收器与应用程序交替工作，以尽可能减少应用程序的停顿时间

  - 独占式

    - ![[Pasted image 20230313225650.png]]

    - 一旦运行，就停止应用程序中所有的用户线程 STW，直到垃圾回收过程完全结束

    - 并行与串行都是独占式

- 按照碎片处理方式

  - 压缩式 标记-压缩算法、复制算法、指针碰撞

  - 非压缩式 标记-清除算法、空闲列表

- 按个工作内存区间分

  - 年轻代

  - 老年代

### GC 性能指标

- 性能指标

  - <font color="#ff0000">吞吐量</font>

    - 总运行时间：程序的运行时间+内存回收的时间

    - 运行用户代码的时间占总运行时间的比例

    - 吞吐量优先，意味着单位时间内，STW 的时间最短

  - 垃圾收集 overhead

    - 吞吐量的补数，垃圾收集所占用的时间与总运行时间的比例

  - <font color="#ff0000">暂停时间 STW/快速响应</font>

    - 执行垃圾收集时，程序的工作线程被暂停的时间

    - 暂停时间优先，意味着单次 STW 的时间最短，但是频率可能增加

  - 收集频率

    - 相对于应用程序的执行，收集操作发生的频率

  - <font color="#ff0000">内存占用</font>

    - Java 堆区所占的内存大小，越大 GC 越少

  - 快速

    - 一个对象从诞生到被回收经历的时间

- 不可能三角（CAP 理论）

  - 高吞吐量与低暂停时间，是一对互相竞争的。因为如果高吞吐量优先，必然需要降低内存回收的执行频率，导致 GC 需要更长的暂停时间来执行内存回收。

  - 如果选择低延迟优先为原则，也只能频繁的执行内存回收，引起程序吞吐量的下降

  - 所有 GC 只能二选一，或折衷。现在的标准，在最大吞吐量优先的情况下，降低停顿时间

### 不同的垃圾回收器概述

- 垃圾回收器的发展迭代史

  - Serial GC

    - 1999 年 jdk1.3.1

    - 第一款 GC，串行

  - ParNew

    - 是 SerialGC 收集器的多线程版本，并行

  - Parallel GC 和 Concurrent Mark-Sweep GC（CMS）

    - jdk1.4.2

    - 2002 年 2 月 26 日

    - ParallelGC 在 JDK1.6 之后称为 HotSpot 默认 GC

  - G1

    - 2012 年

    - jdk1.7u4

    - 2017 年 JDK9 中 G1 变成默认的垃圾收集器，以替代 CMS

    - 2018 年 3 月，JDK10 中 G1 垃圾回收器的并行完整垃圾回收，实现并行性改善最坏情况下的延迟

  - Epsilon 垃圾回收器、ZGC：可伸缩低延迟垃圾回收器

    - 2018 年 9 月 JDK11

  - Shenandoah GC：低停顿时间的 GC，实验版

    - 2019 年 3 月 JDK12

  - 增强 ZGC

    - 2019 年 9 月 JDK13

  - 删除 CMS 垃圾回收器，扩展 ZGC 在 macOS 和 Windows 上的应用

    - 2020 年 3 月 JDK14

- 经典垃圾收集器工作方式

  - ![[Pasted image 20230313225710.png]]

  - ![[Pasted image 20230313225714.png]]

- 垃圾收集器的组合和垃圾分代关系

  - ![[Pasted image 20230313225719.png]]

  - jdk8 之前，可以用虚线参考关系

  - CMS 下面的实线连接 serial old，是 CMS 回收失败的后备方案

  - JDK8 默认 Parallel Scavenge 和 Parallel old Gc，弃用红线组合。如果要用也可以用。

  - JDK9 默认 G1，删除红线组合

  - jdk14 弃用绿线组合，删除 CMS。仅剩 serial-serialOld、parallel scavenge-parallelOld、G1 三种组合

  - 新生代用了 Parallel Scavenge 则老年代自动触发用 Parallel old

  - Parallel 底层与 ParNew 底层不同，所以不能和 CMS 组合

- 如何查看默认的垃圾收集器

  - -XX:+PrintCommandLineFlags

  - jinfo -flag 相关垃圾回收器参数 进程 ID

    - ![[Pasted image 20230313225725.png]]

### Serial 回收器：串行回收

- Serial 收集器用于新生代，采用复制算法，串行回收和 STW 机制的方式执行内存回收

- 用于老年代的 Serial old 收集器，同样采取了串行回收，但是用标记-压缩算法

  - ![[Pasted image 20230313225730.png]]

  - 使用一个 CPU 或者一条收集线程去完成垃圾收集工作，在进行垃圾收集时，必须暂停其他所有工作线程

- 优势

  - 简单而高效，对于限定单个 CPU 的环境来说，由于<font color="#ff0000">没有线程交互的开销</font>，可以获取<font color="#ff0000">最高的单线程收集效率</font>

- 对于交互强的应用而言，追求低延迟, 不会采取串行垃圾收集器

- HotSpot 虚拟机中，使用-XX:+UseSerialGC 指定年轻代和老年代使用串行收集器

- 多核时代，基本不再使用

### ParNew 回收器：并行回收

- 用于多核 CPU，除了在新生代采用并行回收，其他方面和 Serial 没有任何区别

  - ![[Pasted image 20230313225735.png]]

- -XX:UseParNewGC 手工指定 ParNew 收集器执行内存回收任务，它表示年轻代使用，不影响老年代

- -XX:ParallelGCThreads 限制线程数量，默认开启和 CPU 数据相同的线程数

### Parallel Scavenge/Old 回收器：高吞吐量优先

- Parallel Scavenge 用于年轻代，同采用样复制算法、并行回收、STW 机制，但：

  - 和 ParNew 不同，它的<font color="#ff0000">目标是达到一个可控制的吞吐量</font>

  - <font color="#ff0000">自适应调节策略</font>也是 Parallel 与 ParNew 的一个重要区别

- 适合<font color="#ff0000">后台运算不需要太多交互，重视总吞吐量</font>的任务，例如执行批量处理，订单处理，工资支付，科学计算的应用程序

- Parallel old 采取标记-压缩算法，同样基于并行回收和 STW 机制，目的是取代串行的 serialOld

- 参数配置

  - -XX:+UseParallelGC

    - 手动指定新生代使用 Parallel Scavenge

  - -XX:+UseParallelOldGC

    - 手工指定老年代使用 Parallel old

  - 上面这两个参数关联，开启一个，默认开启另一个。

  - -XX:MaxGCPauseMillis

    - 设置收集器最大 STW 时间，单位毫秒

    - 该参数谨慎使用，强控 STW 会改变 JVM 其他参数，比如 STW 很小-\>Heap 变小-\>频率变高-\>总吞吐量下降

  - -XX:GCTimeRatio

    - 垃圾收集占总时间比，用于衡量吞吐量大小

      - 默认 99，也就是垃圾回收时间不超过 1%

  - 上面这两个参数矛盾，暂停时间越短，吞吐量越低，Ratio 越容易超

  - -XX:ParallelGCThreads

    - 设置年轻代并行收集器的线程数，一般与 CPU 数量相同，如果 CPU 数量大于 8 个，则值=3+（5\*N/8）

  - -XX:+UseAdaptiveSizePolicy

    - 开启自适应调节策略

      - 这种模式下，年轻代大小，Eden 和 Survivor 的比例，晋升老年底对象年龄参数都会被自动调整

      - 为了达到堆大小，吞吐量和停顿时间之间的平衡点

      - 在手动调优比较困难的场景下，可以直接用自适应方式，仅指定虚拟机最大堆，目标吞吐量和停顿时间，让虚拟机自己完成调优工作

### CMS 回收器：低 STW 优先

- jdk1.5 推出 Concurrent Mark-Sweep（并发标记-清除）用于老年代，第一次实现了让垃圾收集线程与用户线程并发工作

  - ![[Pasted image 20230313225744.png]]

  - 初始标记：STW，仅仅只是标记出<font color="#ff0000">GC Roots 能直接关联的可达对象（根节点下一层孩子）</font>，一旦标记完成后就会恢复之前被暂停的所有应用线程，<font color="#ff0000">由于直接关联对象比较少，所以即使是单线程速度也非常快</font>

  - 并发标记：从 GCRoots 的直接关联对象开始<font color="#ff0000">遍历整个对象图</font>的过程，这个过程耗时较长

    - 因此不停顿用户线程，与垃圾收集线程一起并发运行，将长耗时均摊到并发过程中

    - 但与此同时，用户线程也可能使得初始标记改变（错标存活对象为垃圾），还可能产生新的 GCRoots（多标）

  - 重新标记：STW，<font color="#ff0000"><a class="link" target="_bank" href="https://blog.csdn.net/weixin_48460141/article/details/124000465">修正</a></font>并发标记期间，因用户程序继续运作导致的错标，方法为增量更新。至此，标记结束。

  - 并发清理：清理标记阶段判断的垃圾对象，释放内存空间

    - 为了低延迟，这个阶段也与用户线程并发，因此使用<font color="#ff0000">标记-清除算法：</font><font color="#000000">比标记压缩快,</font>不需要移动存活对象，VMS、常量池、静态区等引用保持不变。但会产生碎片

    - 同样，因为并发执行，也会产生新的 GCRoots

  - 以上过程即为<a class="link" target="_bank" href="https://blog.csdn.net/m0_46690280/article/details/121941158">三色标记</a>算法

- 初始标记和重新标记阶段仍然需要 STW 机制, 但都很快

- 由于在垃圾收集阶段用户线程没有中断，所以在 CMS 回收过程中，<font color="#ff0000">还应该确保应用程序用户线程有足够的内存可用</font>。因此 CMS 收集器不能像其他收集器那样等到老年代几乎填满再进行回收，而是当<font color="#ff0000">堆内存使用率达到某一阈值</font>时，便开始进行回收。

- 要是 CMS 运行期间预留的内存无法满足并发用户线程的需要，就会出现<font color="#ff0000">Concurrent Mode Failure</font>，这时虚拟机启用兜底方案，临时启用 Serial old 收集器 STW 重新进行老年代的垃圾收集，这样停顿时间就长了。

- CMS 采取标记清除算法，会产生内存碎片，只能选择<font color="#ff0000">空闲列表</font>执行内存分配

- 💡 为什么不采取标记-压缩清除内存碎片呢？

  - 因为并发清除时，如果用压缩整理内存，并发用户线程使用的内存地址就变了。标记-压缩只适合 STW 场景下使用

  - 标记-压缩相对慢, 不符合低延迟目标

  - 对于碎片, 只能执行一定次数 CMS 后，进行整体 FullGC

- 优点

  - 并发收集

  - 低延迟

- 缺点

  - 会产生内存碎片

    - 面对高峰创建请求，使用 CMS 会导致老年代很快充满碎片，然后无法分配大对象，提前触发 FullGC

  - 对 CPU 资源非常敏感

    - 在并发阶段会占用一部分线程导致应用程序变慢，吞吐量受一定影响

  - 无法处理浮动垃圾

    - 并发标记和并发清除阶段是与工作线程同时运行，如果产生新的垃圾对象，CMS 无法进行标记，只能在下一次执行 GC 时释放空间

- 参数

  - -XX:+UseConcMarkSweepGC

    - 手工指定 CMS 收集器执行内存回收任务

    - 开启后，自动将-XX:UseParNewGC 打开，即 ParNew（Young 区）+ CMS（old 区）组合

  - -XX:CMSlnitiatingOccupanyFraction

    - 设置堆内存使用率的阈值

      - 一旦达到该阈值，则开始进行回收

    - jdk5 及之前默认 68，即老年代的空间使用率达到 68%时会执行一次 CMS 回收

    - JDK6 及以上默认值为 92%

    - 如果内存增长缓慢，可以设置一个稍大的值，有效降低 CMS 的触发频率，减少老年代回收的次数

    - 如果应用程序内存使用率增加很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。

  - -XX:+UseCMSCompactAtFullCollection

    - 用于执行完 Full GC 后对内存空间进行压缩整理

    - 不过内存压缩无法并发执行，会带来停顿时间更长的问题

  - -XX:CMSFullGCsBeforeCompaction

    - 设置执行多少次 FullGC 后对内存空间进行压缩整理

  - -XX:ParallelCMSThreads

    - 设置 CMS 的线程数量

      - 默认启动的线程数是(ParallelGCThreads+3)/4

      - ParallelGCThreads 是年轻代并行收集器的线程数

### 小结

- 如果想要最小化使用内存和并行上下文切换的开销，选择 Serial + SerialOld GC

- 如果最大化应用程序的吞吐量，选择 Parallel Scavenge + ParOld GC

- 如果想要最小化的 GC 的中断或停顿时间，选择 ParNew +CMS GC

- 以上三种全采用分代思想，类似内存管理的分段，每段负责不同生命周期的对象管理；

- 而 G1 采用分区思想，类似内存管理的分页，每页可以是任意种类的对象。

### G1 回收器：区域化分代式

- 目标

  - 在内存和 CPU 升级背景下，实现<font color="#ff0000">延迟可控</font>，并获得尽可能高的吞吐量，<font color="#ff0000">全功能</font>收集器

- Garbage First

  - G1 是一个并行回收器，他把堆内存分割为很多不相关的区域（Region）（物理上不连续）

  - 逻辑上使用不同的 region 表示 Eden，s0，s1，老年代等

  - 所有 region 大小相同，且在 JVM 生命周期内不会改变

  - region 可以充当多个角色
  - ![[Pasted image 20230313225801.png]]

  - G1<font color="#ff0000">跟踪各个 region 里面垃圾的价值大小</font>，在后台维护一个<font color="#ff0000">优先列表</font>，每次根据允许的收集时间(延迟)，<font color="#ff0000">优先回收价值最大</font>的 Region

- JDK7 引入，直到 JDK8 还不是默认，需要用-XX:+UseG1GC 来启用, jdk9 以后默认垃圾回收器

- 优势

  - 并行与并发：既可多 CPU 多线程并行工作，此时用户 STW；又可与用户并发交替

  - 同时兼顾年轻代与老年代，并且代结构不再物理连续
  - ![[Pasted image 20230313225817.png]]

  - 空间整合

    - 微观 region 之间用复制算法，整体逻辑分代可以看做是标记-压缩算法。

    - 两种算法都避免内存碎片，有利于程序长时间运行，分配大对象不会因为无法找到连续空间提前触发下一次 GC，尤其当 Java 堆非常大的时候，G1 优势更加明显

  - 可预测的停顿时间模型

    - 能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不能超过 N 毫秒

    - 如果允许延迟过小, 可供选择的高回收价值 region 少, 导致回收效率低, 触发 fullGC

  - 除了 G1 以外的 GC 都使用 JVM 内置单独线程管理, 而 G1 可以使用一部分用户线程, 加速 GC

- 缺点

  - 相较于 CMS，G1 不具备全方位，压倒性优势。比如用户程序运行中，G1 无论是为了垃圾收集设置的<font color="#ff0000">额外内存占用(记忆集)</font>，还是程序运行时的<font color="#ff0000">额外执行负载</font>都要比 CMS 要高

  - 为了解决跨代引用, 每个 region 都维护记忆集, 因此空间利用率不高. 经验上来说，<font color="#ff0000">小内存应用 CMS</font>表现大概率优于 G1，在<font color="#ff0000">大内存上 G1</font>优势发挥更多，<font color="#ff0000">平衡点在 6-8GB</font>

  - 因为能使用用户线程, 可能影响吞吐

- 参数设置

  - -XX:+UseG1GC

  - -XX:G1HeapRegionSize

    - 设置每个 Region 大小，值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆划分出约 2048 个区域，默认是堆内存的 1/2000

  - -XX:MaxGCPauseMillis

    - 设置期望达到的最大 GC 停顿时间指标，JVM 尽力但不保证，默认 200ms

  - -XX:ParallelGCThread

    - 设置 STW 时,并行工作线程数的值，最多设置 8

  - -XX:ConcGCThreads

    - 设置并发标记的线程数，将 N 设置为并行垃圾回收线程数（parallelGCThreads）的 1/4 左右

  - -XX:InitiatingHeapOccupancyPercent

    - 设置触发并发 GC 周期的 Java 堆占用率阈值，超过此值就触发 GC，默认是 45

- 常见开启 G1 的步骤

  - 第一步，开启 G1 垃圾收集器

  - 第二步，设置堆的最大内存

  - 第三步，设置最大的停顿时间

  - G1 提供了三种垃圾回收模式, 在不同的条件下触发

    - YoungGC

    - MixedGC

    - FullGC

- 适用场景

  - 面向服务器端应用，针对具有<font color="#ff0000">大内存，多处理器</font>的机器

  - 最主要应用是需要低 GC 延迟, 如：在堆大小约 6GB 或更大，可预测的暂停时间可以低于 0.5s

  - G1 每次清理一部分 region 来保证每次 GC 停顿时间不会过长

  - G1 好于 CMS 的情况:

    - 超过 50%的 Java 堆被活动数据占用

    - 对象分配频率或年代提升频率变化很大

    - GC 停顿时间过长，长于 0.5~1 秒

- 垃圾回收过程

  - ![[Pasted image 20230313225832.png]]

  - 年轻代 GC

    - 当年轻代 eden 区用尽时

      - <font color="#ff0000">并行独占式</font>收集器

  - 老年代并发标记过程

    - 当堆内存使用到一定值，默认 45%

  - 混合回收

    - 并发标记完成马上开始混合回收

    - G1 老年代回收器不需要整个老年代都被回收，一次只需要扫描回收一小部分高价值老年代的 region 就可以了。

    - 同时这个老年代回收是和年轻代一起被回收的。

  - 有可能 fullGC

- 记忆集(卡表实现)

  - 可能存在<font color="#ff0000">跨代 region 之间引用</font>, 导致可达对象树范围变大, 高频回收新生代也不得不扫描老年代的 region, 降低新生代 GC 效率

  - ![[Pasted image 20230313225843.png]]

  - 每个 region 对应一个记忆集 bit[]，记忆集中每个<font color="#e57373">元素</font>对应一张<font color="#00ff00">卡页</font>, 卡页中可包含多个对象, 只要任一对象被跨代引用, 这页对应的记忆集元素就置为 1, 表示卡页为脏, 可以加入 GCroot

  - 因此需要维护卡表, 每次引用类型数据写操作时，会产生一个写屏障暂时中断操作, 去更新卡表元素的脏度

    - 由于卡页可包含多个对象, 因此可能导致并发场景下维护卡表的伪共享问题

  - 然后检查将要写入的引用指向的对象, 是否和该引用对象类型数据在不同的 region，如果不同就通过 CardTable 把相关的引用信息记录到引用指向对象所在的 Region 对应的记忆集中(上图虚线)

  - 当进行垃圾收集时，在 GC 根节点枚举范围加入记忆集，就可以保证不进行全局扫描，也不会有遗漏

- G1 回收过程一：年轻代 GC

  - 1、扫描 GCRoots

    - 根是指 static 变量指向的对象，正在执行的方法调用链上的局部变量等, 连同 Rset 记录的外部引用作为扫描存活(可达)对象的入口

  - 2、更新 Rset

    - 处理 dirty card queue 中的 card，更新 Rset，此阶段完成后，Rset 可以准确的反应老年代所在的内存分段中对象对新生代的引用

    - Q: 为什么不在创建对象引用时直接判断(是否属于老年代-\>新生代)并更新 Rset, 而是使用 queue 呢?
      > Rset 处理需要线程同步, 零散的判断开销大, 使用 Lazy 标记思想, 先标后统一处理

  - 3、处理 Rset

    - 识别被老年代对象指向的 Eden 中的对象，这些被指向的 Eden 中的对象被认为是存活的对象

  - 4、复制对象

    - 遍历对象树，Eden 区内存段中存活的对象会被复制到 Survivor 区中空的 region，Survivor 区内存段中存活的对象如果年龄未达阈值，会加一，达到阈值会被复制到 old 区中空的 region，如果 Survivor 区空间不够，Eden 空间的部分数据会直接晋升到老年代空间

  - 5、处理非强引用

    - 处理软弱虚引用，终结器引用，本地方法接口引用等。

  - 最终 Eden 空间的数据为空，GC 结束工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片

- G1 回收过程二：年轻代 GC + 老年代并发标记

  - ![[Pasted image 20230313225928.png]]

  - 初始标记

    - 类似 CMS, 先 STW, 标记从根节点直接可达的第一层对象，并且触发一次年轻代 GC, 然后恢复用户线程

  - 根区域扫描阶段

    - 扫描 Survivor 区直接可达的老年代 region 对象，并标记被引用的对象，这个过程在初始标记的 youngGC 之前完成

  - 并发标记

    - 类似 CMS, 和应用程序并发执行，在整个堆中进行可达对象标记
    - 同时计算每个 region 的存活对象比例, 当成回收价值
      - 若发现某 region 中的所有对象都是垃圾，则此 region 无需标记, 会被立即回收

  - 重新标记

    - 类似 CMS, 由于应用程序并发进行，需要修正上次标记结果，STW，G1 采取比 CMS(增量更新)更快的初始快照算法

  - 排序筛选

    - STW, 计算各个 region 存活对象和 GC 回收比例，并进行排序
    - 识别可以混合回收的区域
    - 这个阶段并不会实际上去做垃圾的收集

  - 并发清理
    - 类似 CMS, 识别, 复制并清理不可达垃圾所在的旧 region

- G1 回收过程三：混合回收 =年轻代 GC +老年代 GC

  - 当越来越多的对象晋升到老年代 region 时，为了避免内存被耗尽，虚拟机会触发一次 MixedGC，该算法除了<font color="#ff0000">回收整个 young region</font>，还会<font color="#ff0000">回收一部分的 old region</font>。注意 MixedGC 并不是 FullGC

  - 并发标记结束后，老年代中百分百为垃圾的 region 被回收了，部分为垃圾的 region 算出回收价值，默认情况下，这些老年代的 region 会分 8 次被回收

    - -XX:G1MixedGCCountTarget 设置次数

  - 混合回收的回收集包括八分之一的老年代，Eden 区内存分段，Survivor 区内存分段。方法与年轻代 GC 相同

  - 由于老年代中内存分段默认分 8 次回收，G1 会<font color="#ff0000">优先回收垃圾多的 region</font>(回收价值高)，并且有一个阈值会决定内存分段是否被回收。

    - -XX:G1MixedGCLiveThresholdPercent，默认为 65%, 意思是垃圾占比达到 65%才会被回收。
    - 如果垃圾占比低, 意味存活对象较多，复制的时候花更多时间, 清理出来的空间还少，回收价值小。

  - 混合回收不一定要跑满设置的回收次数, 因为边际效用递减, 随着回收的进行, 高价值 region 越来越少

    - 阈值：-XX:G1HeapWastePercent, 默认值是 10%，意思是允许整个堆内存中有 10%的空间被浪费，意味着当发现可以回收的垃圾占堆内存比例低于 10%，则不再进行混合回收，因为 GC 花费更多的时间，但是回收到的内存却很少。

- G1 可选过程四：fullGC

  - G1 初衷就是要避免 FullGC，如果<font color="#ff0000">上述方式不能正常工作</font>，G1 会 STW, 使用单线程的 FullGC。
  - 比如堆太小，当 G1 复制存活对象的时候没有空的内存分段可用，则会回退到 FullGC

  - 导致 FullGC 的直接原因有两个
    - 回收阶段的时候没有足够的 to-space 存放晋升的对象
    - 并发处理过程完成之前空间耗尽了
    - 间接可能是设置停顿时间过短, 使高价值 region 过少, 用户线程并发执行不断累积超过了回收速度, 造成内存耗尽

- 优化建议

  - 避免使用-Xmn 或-XX:NewRatio 等相关选项显式固定年轻代大小
    - 年轻代是独占式的, 固定的年轻代大小会覆盖暂停时间目标
  - 暂停时间目标不要太苛刻，太苛刻会影响吞吐量

### 垃圾回收器总结

- ![[Pasted image 20230313225941.png]]

### GC 可配参数和日志分析

- ![[Pasted image 20230313225946.png]]

- ![[Pasted image 20230313225952.png]]

- ![[Pasted image 20230313225956.png]]

- ![[Pasted image 20230313230001.png]]

- ![[Pasted image 20230313230006.png]]

- ![[Pasted image 20230313230010.png]]

- GC EASY

### 垃圾回收器的新发展

- ![[Pasted image 20230313230016.png]]

- Shenandoah GC

  - 强项
    - 低延迟时间
  - 弱项
    - 高运行负担下的吞吐量下降

- ZGC

  - 在尽可能堆吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾回收的停顿时间限制在 10 毫秒以内的低延迟
  - 并发标记，并发预备重分配，并发重分配，并发重映射
  - 除了初始标记是 STW，其他地方几乎都是并发执行的
  - \<新一代垃圾回收器\_ZGC 设计与实现\>

- 面试问法: GC 算法有哪些? 如何判断对象是否可被回收? GC 工作流程? 常用参数?
