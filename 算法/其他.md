---
date created: 2023-03-08 18:12
---

## Manacher

```java
public String longestPalindrome(String str) {
	char[] s = process(str);
	int len = s.length;
	int R = -1; // 全局最右回文下标
	int C = -1; // 全局回文中心
	int max = -1;
	int[] maxPalinR = new int[len]; // 每个位置的最大回文半径

	for (int i = 0; i < len; ++i) {

		maxPalinR[i] = i < R ? Math.min(R - i, maxPalinR[2 * C - i]) : 1;

		while (i + maxPalinR[i] < len && i - maxPalinR[i] >= 0) {
			if (s[i + maxPalinR[i]] == s[i - maxPalinR[i]]) {
				maxPalinR[i]++;
			} else break;
		}

		if (i + maxPalinR[i] > R) {
			R = i + maxPalinR[i];
			C = i;
		}

		max = Math.max(max, maxPalinR[i]);
	}

	return max - 1;
}
```

## 树

> 埃及分数：正有理数a/b可表示为分子为1，分母不同的分数之和，最少要几个？

* 可行性剪枝 非法条件
* 最优性剪枝 空间树某分支一定比当前最优解差，则剪去
* alphabeta剪枝 双人游戏
* 迭代加深搜索 遍历深度，对每个深度dfs

> 八数码：九宫格缺一个，给定起始状态，变成目标状态的最小移动次数，h可以选不符合最终状态的格子 的个数/到目标格子的曼哈顿距离

* 启发式搜索 相比于dfs的每次遍历第一个孩子，bfs的每次遍历所有孩子，启发式搜索使用评价函数h决定要访问的孩子集合
  * 如果评价函数一定优于真实评价函数，则称为A*

* 贪心的正确性：空间树的唯一选择一定通往全局最优解（数学归纳/反证）

## 二分

> 长度为L的区间存在N块石头，拿掉M块，求石头间最小距离的最大值

* 搜索区间优化为左闭右开，让左右区间状态不一致
* 黑盒二分：不写出评价函数，而是用其他方法(贪心，dp)求对任意输入，满足题目要求的可行解，然后二分输入值
* 分数规划：求min/max x 使得(x/y = ans) -> x = ans * y，构造二分
* 顺序优化：二分时先判断一个区间，在判断相等，最后另一个区间，因为相等概率比较小，这样比较的期望是1.5次

## DP

> 编辑距离 === LCS(如果数组无重复元素) ==> LIS

* 抽象成DAG求最短路，比如LIS，从终点反推起点，每一层要么遍历前缀子数组找最大(n^2)，要么使用二分找最大(nlogn)
* 区间DP：n堆石子，每次选两堆相邻的合并，合并花费最大值？(枚举分割点)   如果允许首尾也合并？(冗余法将环拆成长度为2n的线性问题)
  * 变体：环图，顶点数字，边是运算符，求合并后的最大结果？(因为存在负数，所以需要额外维护最小值状态)
* 状态压缩：某一维状态范围可能很大，导致整体超时，用二进制表示这个维度的状态，用二进制加减表示状态的转移